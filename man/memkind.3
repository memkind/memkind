.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "MEMKIND" "3" "2023-03-03" "MEMKIND | MEMKIND Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-2-Clause
.\" Copyright "2014-2023", Intel Corporation
.SH NAME
.PP
\f[B]memkind\f[R] - A heap manager that enables allocations to memory
with different properties.
.PP
This header expose a STANDARD and an EXPERIMENTAL API.
API Standards are described below in this man page.
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <memkind.h>

Link with -lmemkind
\f[R]
.fi
.PP
\f[B]EXPERIMENTAL API:\f[R]
.IP
.nf
\f[C]
HEAP MANAGEMENT:
int memkind_posix_memalign(memkind_t kind, void **memptr, size_t alignment, size_t size);

KIND MANAGEMENT:
int memkind_create_kind(memkind_memtype_t memtype_flags, memkind_policy_t policy, memkind_bits_t flags, memkind_t *kind);
\f[R]
.fi
.PP
\f[B]STANDARD API:\f[R]
.IP
.nf
\f[C]
ERROR HANDLING:
void memkind_error_message(int err, char *msg, size_t size);

LIBRARY VERSION:
int memkind_get_version();

HEAP MANAGEMENT:
void *memkind_malloc(memkind_t kind, size_t size);
void *memkind_calloc(memkind_t kind, size_t num, size_t size);
void *memkind_realloc(memkind_t kind, void *ptr, size_t size);
void memkind_free(memkind_t kind, void *ptr);
size_t memkind_malloc_usable_size(memkind_t kind, void *ptr);
void *memkind_defrag_reallocate(memkind_t kind, void *ptr);
memkind_t memkind_detect_kind(void *ptr);

KIND CONFIGURATION MANAGEMENT:
struct memkind_config *memkind_config_new();
void memkind_config_delete(struct memkind_config *cfg);
void memkind_config_set_path(struct memkind_config *cfg, const char *pmem_dir);
void memkind_config_set_size(struct memkind_config *cfg, size_t pmem_size);
void memkind_config_set_memory_usage_policy(struct memkind_config *cfg, memkind_mem_usage_policy policy);

KIND MANAGEMENT:
int memkind_create_fixed(void *addr, size_t size, memkind_t *kind);
int memkind_create_pmem(const char *dir, size_t max_size, memkind_t *kind);
int memkind_create_pmem_with_config(struct memkind_config *cfg, memkind_t *kind);
int memkind_destroy_kind(memkind_t kind);
int memkind_check_available(memkind_t kind);
ssize_t memkind_get_capacity(memkind_t kind);
int memkind_check_dax_path(const char *pmem_dir);
void memkind_set_allow_zero_allocs(memkind_t kind, bool allow_zero_allocs);

STATISTICS:
int memkind_update_cached_stats(void);
int memkind_get_stat(memkind_t kind, memkind_stat stat, size_t *value);
int memkind_stats_print(void (*write_cb) (void *, const char *), void *cbopaque, memkind_stat_print_opt opts);

DECORATORS:
void memkind_malloc_pre(memkind_t *kind, size_t *size);
void memkind_malloc_post(memkind_t kind, size_t size, void **result);
void memkind_calloc_pre(memkind_t *kind, size_t *nmemb, size_t *size);
void memkind_calloc_post(memkind_t kind, size_t nmemb, size_t size, void **result);
void memkind_posix_memalign_pre(memkind_t *kind, void **memptr, size_t *alignment, size_t *size);
void memkind_posix_memalign_post(memkind_t kind, void **memptr, size_t alignment, size_t size, int *err);
void memkind_realloc_pre(memkind_t *kind, void **ptr, size_t *size);
void memkind_realloc_post(memkind_t *kind, void *ptr, size_t size, void **result);
void memkind_free_pre(memkind_t *kind, void **ptr);
void memkind_free_post(memkind_t kind, void *ptr);

ENHANCEMENTS:
int memkind_set_bg_threads(bool state);
\f[R]
.fi
.SH DESCRIPTION
.SS ERROR HANDLING
.TP
\f[B]\f[CB]void memkind_error_message(int err, char *msg, size_t size)\f[B]\f[R]
converts an error number err returned by a member of the memkind
interface to an error message \f[I]msg\f[R] where the maximum size of
the message is passed by the \f[I]size\f[R] parameter.
.SS HEAP MANAGEMENT
.PP
The functions described in this section define a heap manager with an
interface modeled on the ISO C standard API\[cq]s, except that the user
must specify the kind of memory with the first argument to each
function.
See the \f[B]KINDS\f[R] section below for a full description of the
implemented kinds.
For the file-backed kind of memory see \f[C]memkind_create_pmem()\f[R]
or \f[C]memkind_create_pmem_with_config()\f[R].
For the memory kind created on user-specified area, please check
\f[C]memkind_create_fixed()\f[R].
.TP
\f[B]\f[CB]void *memkind_malloc(memkind_t kind, size_t size)\f[B]\f[R]
allocates \f[I]size\f[R] bytes of uninitialized memory of the specified
\f[I]kind\f[R].
The allocated space is suitably aligned (after possible pointer
coercion) for storage of any type of object.
If \f[I]size\f[R] is 0, then \f[C]memkind_malloc()\f[R] returns
\f[I]NULL\f[R].
.TP
\f[B]\f[CB]void *memkind_calloc(memkind_t kind, size_t num, size_t size)\f[B]\f[R]
allocates space for \f[I]num\f[R] objects each \f[I]size\f[R] bytes in
length in memory of the specified \f[I]kind\f[R].
The result is identical to calling \f[C]memkind_malloc()\f[R] with an
argument of \f[I]num\f[R] * \f[I]size\f[R], with the exception that the
allocated memory is explicitly initialized to zero bytes.
If \f[I]num\f[R] or \f[I]size\f[R] is 0, then \f[C]memkind_calloc()\f[R]
returns \f[I]NULL\f[R].
.TP
\f[B]\f[CB]void *memkind_realloc(memkind_t kind, void *ptr, size_t size)\f[B]\f[R]
changes the size of the previously allocated memory referenced by
\f[I]ptr\f[R] to \f[I]size\f[R] bytes of the specified \f[I]kind\f[R].
The contents of the memory remain unchanged up to the lesser of the new
and old sizes.
If the new size is larger, the contents of the newly allocated portion
of the memory are undefined.
Upon success, the memory referenced by \f[I]ptr\f[R] is freed and a
pointer to the newly allocated memory is returned.
\f[B]Note:\f[R] \f[C]memkind_realloc()\f[R] may move the memory
allocation, resulting in a different return value than \f[I]ptr\f[R].
.PD 0
.P
.PD
If \f[I]ptr\f[R] is \f[I]NULL\f[R], the \f[C]memkind_realloc()\f[R]
function behaves identically to \f[C]memkind_malloc()\f[R] for the
specified size.
If \f[I]size\f[R] is equal to zero, and \f[I]ptr\f[R] is not
\f[I]NULL\f[R], then the call is equivalent to
\f[C]memkind_free(kind, ptr)\f[R] and \f[I]NULL\f[R] is returned.
The address \f[I]ptr\f[R], if not \f[I]NULL\f[R], must have been
returned by a previous call to \f[C]memkind_malloc()\f[R],
\f[C]memkind_calloc()\f[R], \f[C]memkind_realloc()\f[R],
\f[C]memkind_defrag_reallocate()\f[R] or
\f[C]memkind_posix_memalign()\f[R] with the same \f[I]kind\f[R] as
specified to the call to \f[C]memkind_realloc()\f[R].
Otherwise, if \f[C]memkind_free(kind, ptr)\f[R] was called before,
undefined behavior occurs.
In cases where the kind is unknown in the context of the call to
\f[C]memkind_realloc()\f[R] \f[I]NULL\f[R] can be given as the
\f[I]kind\f[R] specified to \f[C]memkind_realloc()\f[R], but this will
require an internal lookup for a correct kind.
\f[B]Note:\f[R] The lookup for \f[I]kind\f[R] could result in a serious
performance penalty, which can be avoided by specifying a correct
\f[I]kind\f[R].
If both \f[I]kind\f[R] and \f[I]ptr\f[R] are \f[I]NULL\f[R], then
\f[C]memkind_realloc()\f[R] returns \f[I]NULL\f[R] and sets
\f[I]errno\f[R] to \f[B]EINVAL\f[R].
.TP
\f[B]\f[CB]int memkind_posix_memalign(memkind_t kind, void **memptr, size_t alignment, size_t size)\f[B]\f[R]
allocates \f[I]size\f[R] bytes of memory of a specified \f[I]kind\f[R]
such that the allocation\[cq]s base address is an even multiple of
\f[I]alignment\f[R], and returns the allocation in the value pointed to
by \f[I]memptr\f[R].
The requested \f[I]alignment\f[R] must be a power of 2 at least as large
as \f[I]sizeof(void\f[R])\f[I]. If \f[R]size* is 0, then
\f[C]memkind_posix_memalign()\f[R] returns 0, with a \f[I]NULL\f[R]
returned in \f[I]memptr\f[R].
.TP
\f[B]\f[CB]size_t memkind_malloc_usable_size(memkind_t kind, void *ptr)\f[B]\f[R]
function provides the same semantics as \f[C]malloc_usable_size(3)\f[R],
but operates on the specified \f[I]kind\f[R].
\f[B]NOTE:\f[R] In cases where the kind is unknown in the context of the
call to \f[C]memkind_malloc_usable_size()\f[R] \f[I]NULL\f[R] can be
given as the \f[I]kind\f[R], but this could require an internal lookup
for correct kind.
\f[C]memkind_malloc_usable_size()\f[R] is supported by the TBB heap
manager described in the ENVIRONMENT section, since Intel TBB 2019
Update 4.
.TP
\f[B]\f[CB]void *memkind_defrag_reallocate(memkind_t kind, void *ptr)\f[B]\f[R]
reallocates the object conditionally inside the specific \f[I]kind\f[R].
The function determines if it\[cq]s worthwhile to move allocation to the
reduce degree of external fragmentation of the heap.
In case of failure function returns \f[I]NULL\f[R], otherwise function
returns a pointer to reallocated memory and memory referenced by
\f[I]ptr\f[R] was released and should not be accessed.
If \f[I]ptr\f[R] is \f[I]NULL\f[R], then
\f[C]memkind_defrag_reallocate()\f[R] returns \f[I]NULL\f[R].
In cases where the \f[I]kind\f[R] is unknown in the context of the call
to \f[C]memkind_defrag_reallocate()\f[R] \f[I]NULL\f[R] can be given as
the \f[I]kind\f[R] specified to \f[C]memkind_defrag_reallocate()\f[R],
but this will require an internal lookup for the correct \f[I]kind\f[R].
\f[B]Note:\f[R] The lookup for \f[I]kind\f[R] could result in a serious
performance penalty, which can be avoided by specifying a correct
\f[I]kind\f[R].
.TP
\f[B]\f[CB]memkind_t memkind_detect_kind(void *ptr)\f[B]\f[R]
returns the kind associated with allocated memory referenced by
\f[I]ptr\f[R].
This pointer must have been returned by a previous call to
\f[C]memkind_malloc()\f[R], \f[C]memkind_calloc()\f[R],
\f[C]memkind_realloc()\f[R], \f[C]memkind_defrag_reallocate()\f[R] or
\f[C]memkind_posix_memalign()\f[R].
If \f[I]ptr\f[R] is \f[I]NULL\f[R], then \f[C]memkind_detect_kind()\f[R]
returns \f[I]NULL\f[R].
\f[B]Note:\f[R] This function has non-trivial performance overhead.
.TP
\f[B]\f[CB]void memkind_free(memkind_t kind, void *ptr)\f[B]\f[R]
causes the allocated memory referenced by \f[I]ptr\f[R] to be made
available for future allocations.
This pointer must have been returned by a previous call to
\f[C]memkind_malloc()\f[R], \f[C]memkind_calloc()\f[R],
\f[C]memkind_realloc()\f[R], \f[C]memkind_defrag_reallocate()\f[R] or
\f[C]memkind_posix_memalign()\f[R].
Otherwise, if \f[C]memkind_free(*kind*, *ptr*)\f[R] has already been
called before, undefined behavior occurs.
If \f[I]ptr\f[R] is \f[I]NULL\f[R], no operation is performed.
In cases where the kind is unknown in the context of the call to
\f[C]memkind_free()\f[R] \f[I]NULL\f[R] can be given as the
\f[I]kind\f[R], but this will require an internal lookup for correct
kind.
\f[B]Note:\f[R] The lookup for \f[I]kind\f[R] could result in a serious
performance penalty, which can be avoided by specifying a correct
\f[I]kind\f[R].
.SS KIND CONFIGURATION MANAGEMENT
.PP
The functions described in this section define a way to create, delete
and update kind specific configuration.
Except of \f[C]memkind_config_new()\f[R], user must specify the memkind
configuration with the first argument to each function.
API described here is most useful with file-backed kind of memory, e.g.
\f[C]memkind_create_pmem_with_config()\f[R] method.
.TP
\f[B]\f[CB]struct memkind_config *memkind_config_new()\f[B]\f[R]
creates the memkind configuration.
.TP
\f[B]\f[CB]void memkind_config_delete(struct memkind_config *cfg)\f[B]\f[R]
deletes previously created memkind configuration, which must have been
returned by a previous call to \f[C]memkind_config_new()\f[R].
.TP
\f[B]\f[CB]void memkind_config_set_path(struct memkind_config *cfg, const char *pmem_dir)\f[B]\f[R]
updates the memkind \f[I]pmem_dir\f[R] configuration parameter, which
specifies the directory path, where file-backed kind of memory will be
created.
\f[B]Note:\f[R] This function does not validate that \f[I]pmem_dir\f[R]
specifies a valid path.
.TP
\f[B]\f[CB]void memkind_config_set_size(struct memkind_config *cfg, size_t pmem_size)\f[B]\f[R]
updates the memkind \f[I]pmem_size\f[R] configuration parameter, which
allows to limit the file-backed kind memory partition.
\f[B]Note:\f[R] This function does not validate that \f[I]pmem_size\f[R]
is in valid range.
.TP
\f[B]\f[CB]void memkind_config_set_memory_usage_policy(struct memkind_config *cfg, memkind_mem_usage_policy policy)\f[B]\f[R]
updates the memkind \f[I]policy\f[R] configuration parameter, which
allows to tune up memory utilization.
The user should set the value based on the characteristics of the
application that is using the library (e.g.\ prioritize memory usage,
CPU utilization), for more details about \f[I]policy\f[R] see the MEMORY
USAGE POLICY section below.
\f[B]Note:\f[R] This function does not validate that \f[I]policy\f[R] is
in valid range.
.SS KIND MANAGEMENT
.PP
There are built-in kinds that are always available and these are
enumerated in the KINDS section.
The user can also create their own kinds of memory.
This section describes the API\[cq]s that enable the tracking of the
different kinds of memory and determining their properties.
.TP
\f[B]\f[CB]int memkind_create_fixed(void *addr, size_t size, memkind_t *kind)\f[B]\f[R]
is a function used to create a kind under user-specified area of memory.
The memory can be allocated in any possible way, e.g.\ it might be a
static array or an mmapped area.
User can specify any properties using functions such as mbind.
User is also responsible for de-allocation of memory after the kind
destruction.
The memory area must remain valid until fixed_kind is destroyed.
The area starts at address \f[I]addr\f[R] and has size \f[I]size\f[R].
When heap manager runs out of memory (located under user-specified
area), a call to \f[B]memkind_malloc()\f[R] returns \f[I]NULL\f[R] and
\f[B]errno\f[R] is set to \f[B]ENOMEM\f[R].
.TP
\f[B]\f[CB]int memkind_create_pmem(const char *dir, size_t max_size, memkind_t *kind)\f[B]\f[R]
is a convenient function used to create a file-backed kind of memory.
It allocates a temporary file in the given directory \f[I]dir\f[R].
The file is created in a fashion similar to \f[B]tmpfile(3)\f[R], so
that the file name does not appear when the directory is listed and the
space is automatically freed when the program terminates.
The file is truncated to a size of \f[I]max_size\f[R] bytes and the
resulting space is memory-mapped.
Note that the actual file system space is not allocated immediately, but
only on a call to \f[C]memkind_pmem_mmap()\f[R] (see memkind_pmem(3)).
This allows to create a pmem memkind of a pretty large size without the
need to reserve in advance the corresponding file system space for the
entire heap.
If the value of \f[I]max_size\f[R] equals 0, pmem memkind is only
limited by the capacity of the file system mounted under \f[I]dir\f[R]
argument.
The minimum \f[I]max_size\f[R] value which allows to limit the size of
kind by the library is defined as \f[B]MEMKIND_PMEM_MIN_SIZE\f[R].
Calling \f[C]memkind_create_pmem()\f[R] with a size smaller than that
and different than 0 will return an error.
The maximum allowed size is not limited by \f[B]memkind\f[R], but by the
file system specified by the \f[I]dir\f[R] argument.
The \f[I]max_size\f[R] passed in is the raw size of the memory pool and
\f[B]jemalloc\f[R] will use some of that space for its own metadata.
Returns zero if the pmem memkind is created successfully or an error
code from the ERRORS section if not.
.TP
\f[B]\f[CB]int memkind_create_pmem_with_config(struct memkind_config *cfg, memkind_t *kind)\f[B]\f[R]
is a second function used to create a file-backed kind of memory.
Function behaves similar to \f[C]memkind_create_pmem()\f[R] but instead
of passing \f[I]dir\f[R] and \f[I]max_size\f[R] arguments, it uses
\f[I]config\f[R] param to specify characteristics of created file-backed
kind of memory (see \f[B]KIND CONFIGURATION MANAGEMENT\f[R] section).
.TP
\f[B]\f[CB]int memkind_create_kind(memkind_memtype_t memtype_flags, memkind_policy_t policy, memkind_bits_t flags, memkind_t *kind)\f[B]\f[R]
creates kind that allocates memory with specific memory type, memory
binding policy and flags (see MEMORY FLAGS section).
The \f[I]memtype_flags\f[R] (see MEMORY TYPES section) determine memory
types to allocate, \f[I]policy\f[R] argument is policy for specifying
page binding to memory types selected by \f[I]memtype_flags\f[R].
Returns zero if the specified kind is created successfully or an error
code from the ERRORS section if not.
.TP
\f[B]\f[CB]int memkind_destroy_kind(memkind_t kind)\f[B]\f[R]
destroys previously created kind object, which must have been returned
by a previous call to \f[C]memkind_create_pmem()\f[R],
\f[C]memkind_create_pmem_with_config()\f[R] or
\f[C]memkind_create_kind()\f[R].
Otherwise, or if \f[C]*memkind_destroy_kind(kind)*\f[R] has already been
called before, undefined behavior occurs.
Note that, when the kind was returned by \f[C]memkind_create_kind()\f[R]
all allocated memory must be freed before kind is destroyed, otherwise
this will cause memory leak.
When the kind was returned by \f[C]memkind_create_pmem()\f[R] or
\f[C]memkind_create_pmem_with_config()\f[R] all allocated memory will be
freed after kind will be destroyed.
.TP
\f[B]\f[CB]int memkind_check_available(memkind_t kind)\f[B]\f[R]
returns zero if the specified \f[I]kind\f[R] is available or an error
code from the ERRORS section if it is not.
.TP
\f[B]\f[CB]ssize_t memkind_get_capacity(memkind_t kind)\f[B]\f[R]
returns memory capacity of nodes available to a given kind (file size or
filesystem capacity in case of a file-backed PMEM kind; total area size
in the case of fixed-kind) or -1 in case of an error.
Supported kinds are: \f[B]MEMKIND_DEFAULT, MEMKIND_HIGHEST_CAPACITY,
MEMKIND_HIGHEST_CAPACITY_LOCAL, MEMKIND_LOWEST_LATENCY_LOCAL,
MEMKIND_HIGHEST_BANDWIDTH_LOCAL, MEMKIND_HUGETLB, MEMKIND_INTERLEAVE,
MEMKIND_HBW, MEMKIND_HBW_ALL, MEMKIND_HBW_INTERLEAVE, MEMKIND_DAX_KMEM,
MEMKIND_DAX_KMEM_ALL, MEMKIND_DAX_KMEM_INTERLEAVE, MEMKIND_REGULAR\f[R],
file-backed PMEM and fixed-kind.
\f[I]kind\f[R].
For \f[B]MEMKIND_HUGETLB\f[R] only pages with a default size of 2MB are
supported.
.TP
\f[B]\f[CB]int memkind_check_dax_path(const char *pmem_dir)\f[B]\f[R]
returns zero if file-backed kind memory is in the specified directory
path \f[I]pmem_dir\f[R].
Otherwise, it can be created with the DAX attribute or an error code
from the ERRORS section.
.TP
\f[B]\f[CB]void memkind_set_allow_zero_allocs(memkind_t kind, bool allow_zero_allocs)\f[B]\f[R]
for a given \f[I]kind\f[R], determines the behavior of malloc-like
functions when size passed to them is equal to zero.
These functions return a valid pointer when \f[I]allow_zero_allocs\f[R]
is set to true, return NULL when set to false (default memkind
behavior).
.PP
\f[B]MEMKIND_PMEM_MIN_SIZE\f[R] The minimum size which allows to limit
the file-backed memory partition.
.SS STATISTICS
.PP
The functions described in this section define a way to get specific
memory allocation statistics.
.TP
\f[B]\f[CB]int memkind_update_cached_stats(void)\f[B]\f[R]
is used to force an update of cached dynamic allocator statistics.
Statistics are not updated real-time by memkind library and this method
allows to force its update.
.TP
\f[B]\f[CB]int memkind_get_stat(memkind_t kind, memkind_stat stat, size_t *value)\f[B]\f[R]
retrieves statistic of the specified type and returns it in
\f[I]value\f[R].
Measured statistic applies to the specific \f[I]kind\f[R], when
\f[I]NULL\f[R] is given as \f[I]kind\f[R] then statistic applies to
memory used by the whole memkind library.
\f[B]Note:\f[R] You need to call \f[C]memkind_update_cached_stats()\f[R]
before calling \f[C]memkind_get_stat()\f[R] because statistics are
cached by the memkind library.
.TP
\f[B]\f[CB]int memkind_stats_print(void (*write_cb) (void *, const char *), void *cbopaque, memkind_stat_print_opt opts)\f[B]\f[R]
prints summary statistics.
This function wraps the jemalloc\[cq]s function
\f[C]je_malloc_stats_print()\f[R].
Uses \f[I]write_cb \f[R]function to print the output.
While providing a custom writer function, use \f[C]syscall(2)\f[R]
rather than \f[C]write(2)\f[R].
Pass \f[I]NULL\f[R] in order to use the default \f[I]write_cb\f[R]
function which prints the output to the stderr.
Use \f[I]cbopaque\f[R] parameter in order to pass some data to your
\f[I]write_cb\f[R] function.
Pass additional options using \f[I]opts\f[R].
For more details on opts see the MEMORY STATISTICS PRINT OPTIONS section
below.
Returns MEMKIND_ERROR_INVALID when failed to parse an options string,
MEMKIND_SUCCESS on success.
.SS DECORATORS
.PP
The memkind library enables the user to define decorator functions that
can be called before and after each memkind heap management API.
The decorators that are called at the beginning of the function end are
named after that function with *_pre* appended to the name and those
that are called at the end of the function are named after that function
with *_post* appended to the name.
These are weak symbols and if they are not present at link time they are
not called.
The memkind library does not define these symbols which are reserved for
user definition.
These decorators can be used to track calls to the heap management
interface or to modify parameters.
The decorators that are called at the beginning of the allocator pass
all inputs by reference and the decorators that are called at the end of
the allocator pass the output by reference.
This enables the modification of the input and output of each heap
management function by the decorators.
.SS ENHANCEMENTS
.TP
\f[B]\f[CB]int memkind_set_bg_threads(bool state)\f[B]\f[R]
enables/disables internal background worker threads in jemalloc.
.SS LIBRARY VERSION
.PP
The memkind library version scheme consist major, minor and patch
numbers separated by dot.
Combining those numbers, we got the following representation:
.PP
major.minor.patch, where:
.IP \[bu] 2
major number is incremented whenever the API is changed (loss of
backward compatibility),
.IP \[bu] 2
minor number is incremented whenever additional extensions are
introduced or behavior has been changed,
.IP \[bu] 2
patch number is incremented whenever small bug fixes are added.
.PP
memkind library provide numeric representation of the version by
exposing the following API:
.TP
\f[B]\f[CB]int memkind_get_version()\f[B]\f[R]
returns version number represented by a single integer number, obtained
from the formula:
.PD 0
.P
.PD
major * 1000000 + minor * 1000 + patch
.PP
\f[B]Note:\f[R] major < 1 means an unstable API.
.SS API standards
.IP \[bu] 2
STANDARD API, the API is considered as stable
.IP \[bu] 2
NON-STANDARD API, the API is considered as stable, however this is not a
standard way to use memkind
.IP \[bu] 2
EXPERIMENTAL API, the API is considered as unstable and the subject to
change
.SH RETURN VALUE
.PP
\f[C]memkind_calloc()\f[R], \f[C]memkind_malloc()\f[R],
\f[C]memkind_realloc()\f[R] and \f[C]memkind_defrag_reallocate()\f[R]
returns the pointer to the allocated memory or \f[I]NULL\f[R] if the
request fails.
\f[C]memkind_malloc_usable_size()\f[R] returns the number of usable
bytes in the block of allocated memory pointed to by ptr, a pointer to a
block of memory allocated by \f[C]memkind_malloc()\f[R] or a related
function.
If \f[I]ptr\f[R] is \f[I]NULL\f[R], 0 is returned.
\f[C]memkind_free()\f[R] and \f[C]memkind_error_message()\f[R] do not
have return values.
All other memkind API\[cq]s return 0 upon success and an error code
defined in the ERRORS section upon failure.
The memkind library avoids setting \f[I]errno\f[R] directly, but calls
to underlying libraries and system calls may set \f[I]errno\f[R]
(e.g.\ \f[C]memkind_create_pmem()\f[R]).
.SH KINDS
.PP
\f[B]The available kinds of memory:\f[R]
.TP
MEMKIND_DEFAULT
Default allocation using standard memory and default page size.
.TP
MEMKIND_HIGHEST_CAPACITY
Allocate from a NUMA node(s) that has the highest capacity among all
nodes in the system.
.TP
MEMKIND_HIGHEST_CAPACITY_PREFERRED
Same as \f[B]MEMKIND_HIGHEST_CAPACITY\f[R] except that if there is not
enough memory in the NUMA node that has the highest capacity in the
local domain to satisfy the request, the allocation will fall back on
other memory NUMA nodes.
\f[B]Note:\f[R] For this kind, the allocation will not succeed if there
are two or more NUMA nodes that have the highest capacity.
.TP
MEMKIND_HIGHEST_CAPACITY_LOCAL
Allocate from a NUMA node that has the highest capacity among all NUMA
Nodes from the local domain.
NUMA Nodes have the same local domain for a set of CPUs associated with
them, e.g.\ socket or sub-NUMA cluster.
\f[B]Note:\f[R] If there are multiple NUMA nodes in the same local
domain that have the highest capacity - allocation will be done from a
NUMA node with a worse latency attribute.
This kind requires locality information described in the SYSTEM
CONFIGURATION section.
.TP
MEMKIND_HIGHEST_CAPACITY_LOCAL_PREFERRED
Same as \f[B]MEMKIND_HIGHEST_CAPACITY_LOCAL\f[R] except that if there is
not enough memory in the NUMA node that has the highest capacity to
satisfy the request, the allocation will fall back on other memory NUMA
nodes.
.TP
MEMKIND_LOWEST_LATENCY_LOCAL
Allocate from a NUMA node that has the lowest latency among all NUMA
Nodes from the local domain.
NUMA Nodes have the same local domain for a set of CPUs associated with
them, e.g.\ socket or sub-NUMA cluster.
Note: If there are multiple NUMA nodes in the same local domain that
have the lowest latency - allocation will be done from a NUMA node with
smaller memory capacity.
This kind requires locality and memory performance characteristics
information described in the SYSTEM CONFIGURATION section.
.TP
MEMKIND_LOWEST_LATENCY_LOCAL_PREFERRED
Same as \f[B]MEMKIND_LOWEST_LATENCY_LOCAL\f[R] except that if there is
not enough memory in the NUMA node that has the lowest latency to
satisfy the request, the allocation will fall back on other memory NUMA
nodes.
.TP
MEMKIND_HIGHEST_BANDWIDTH_LOCAL
Allocate from a NUMA node that has the highest bandwidth among all NUMA
Nodes from the local domain.
NUMA Nodes have the same local domain for a set of CPUs associated with
them, e.g.\ socket or sub-NUMA cluster.
Note: If there are multiple NUMA nodes in the same local domain that
have the highest bandwidth - allocation will be done from a NUMA node
with smaller memory capacity.
This kind requires locality and memory performance characteristics
information described in the SYSTEM CONFIGURATION section.
.TP
MEMKIND_HIGHEST_BANDWIDTH_LOCAL_PREFERRED
Same as \f[B]MEMKIND_HIGHEST_BANDWIDTH_LOCAL\f[R] except that if there
is not enough memory in the NUMA node that has the highest bandwidth to
satisfy the request, the allocation will fall back on other memory NUMA
nodes.
.TP
MEMKIND_HUGETLB
Allocate from standard memory using huge pages.
\f[B]Note:\f[R] This kind requires huge pages configuration described in
the SYSTEM CONFIGURATION section.
.TP
MEMKIND_INTERLEAVE
Allocate pages interleaved across all NUMA nodes with transparent huge
pages disabled.
.TP
MEMKIND_HBW
Allocate from the closest high bandwidth memory NUMA node(s) at the time
of allocation.
If there is not enough high bandwidth memory to satisfy the request
\f[I]errno\f[R] is set to \f[B]ENOMEM\f[R] and the allocated pointer is
set to NULL.
\f[B]Note:\f[R] This kind requires memory performance characteristics
information described in the SYSTEM CONFIGURATION section.
.TP
MEMKIND_HBW_ALL
Same as \f[B]MEMKIND_HBW except\f[R] decision regarding closest NUMA
node(s) is postponed until the time of the first write.
.TP
MEMKIND_HBW_HUGETLB
Same as \f[B]MEMKIND_HBW\f[R] except the allocation is backed by huge
pages.
\f[B]Note:\f[R] This kind requires huge pages configuration described in
the SYSTEM CONFIGURATION section.
.TP
MEMKIND_HBW_ALL_HUGETLB
Combination of \f[B]MEMKIND_HBW_ALL\f[R] and
\f[B]MEMKIND_HBW_HUGETLB\f[R] properties.
\f[B]Note:\f[R] This kind requires huge pages configuration described in
the SYSTEM CONFIGURATION section.
.TP
MEMKIND_HBW_PREFERRED
Same as \f[B]MEMKIND_HBW\f[R] except that if there is not enough high
bandwidth memory to satisfy the request, the allocation will fall back
on standard memory.
\f[B]Note:\f[R] For this kind, the allocation will not succeed if two or
more high bandwidth memory NUMA nodes are in the same shortest distance
to the same CPU on which process is eligible to run.
Check on that eligibility is done upon starting the application.
.TP
MEMKIND_HBW_PREFERRED_HUGETLB
Same as \f[B]MEMKIND_HBW_PREFERRED\f[R] except the allocation is backed
by huge pages.
\f[B]Note:\f[R] This kind requires huge pages configuration described in
the SYSTEM CONFIGURATION section.
.TP
MEMKIND_HBW_INTERLEAVE
Same as \f[B]MEMKIND_HBW\f[R] except that the pages that support the
allocation are interleaved across all high bandwidth nodes and
transparent huge pages are disabled.
.TP
MEMKIND_DAX_KMEM
Allocate from the closest persistent memory NUMA node at the time of
allocation.
If there is not enough memory in the closest persistent memory NUMA node
to satisfy the request \f[I]errno\f[R] is set to \f[B]ENOMEM\f[R] and
the allocated pointer is set to \f[I]NULL\f[R].
.TP
MEMKIND_DAX_KMEM_ALL
Allocate from the closest persistent memory NUMA node available at the
time of allocation.
If there is not enough memory on any of persistent memory NUMA nodes to
satisfy the request \f[I]errno\f[R] is set to \f[B]ENOMEM\f[R] and the
allocated pointer is set to \f[I]NULL\f[R].
.TP
MEMKIND_DAX_KMEM_PREFERRED
Same as \f[B]MEMKIND_DAX_KMEM\f[R] except that if there is not enough
memory in the closest persistent memory NUMA node to satisfy the
request, the allocation will fall back on other memory NUMA nodes.
\f[B]Note:\f[R] For this kind, the allocation will not succeed if two or
more persistent memory NUMA nodes are in the same shortest distance to
the same CPU on which process is eligible to run.
Check on that eligibility is done upon starting the application.
.TP
MEMKIND_DAX_KMEM_INTERLEAVE
Same as \f[B]MEMKIND_DAX_KMEM\f[R] except that the pages that support
the allocation are interleaved across all persistent memory NUMA nodes.
.TP
MEMKIND_REGULAR
Allocate from regular memory using the default page size.
Regular means general purpose memory from the NUMA nodes containing
CPUs.
.SH MEMORY TYPES
.PP
The available types of memory:
.TP
MEMKIND_MEMTYPE_DEFAULT
Standard memory, the same as the process uses.
.TP
MEMKIND_MEMTYPE_HIGH_BANDWIDTH
High bandwidth memory (HBM).
There must be at least two memory types with different bandwidth to
determine which is the HBM.
.SH MEMORY BINDING POLICY
.PP
The available types of memory binding policy:
.TP
MEMKIND_POLICY_BIND_LOCAL
Allocate local memory.
If there is not enough memory to satisfy the request \f[I]errno\f[R] is
set to \f[B]ENOMEM\f[R] and the allocated pointer is set to NULL.
.TP
MEMKIND_POLICY_BIND_ALL
Memory locality is ignored.
If there is not enough memory to satisfy the request \f[I]errno\f[R] is
set to \f[B]ENOMEM\f[R] and the allocated pointer is set to NULL.
.TP
MEMKIND_POLICY_PREFERRED_LOCAL
Allocate preferred memory that is local.
If there is not enough preferred memory to satisfy the request or
preferred memory is not available, the allocation will fall back on any
other memory.
.TP
MEMKIND_POLICY_INTERLEAVE_LOCAL
Interleave allocation across local memory.
For n memory types the allocation will be interleaved across all of
them.
.TP
MEMKIND_POLICY_INTERLEAVE_ALL
Interleave allocation.
Locality is ignored.
For n memory types the allocation will be interleaved across all of
them.
.SH MEMORY FLAGS
.PP
The available types of memory flags:
.TP
MEMKIND_MASK_PAGE_SIZE_2MB
Allocation backed by 2MB page size.
.SH MEMORY USAGE POLICY
.PP
The available types of memory statistics:
.TP
MEMKIND_STAT_TYPE_RESIDENT
Maximum number of bytes in physically resident data pages mapped.
.TP
MEMKIND_STAT_TYPE_ACTIVE
Total number of bytes in active pages.
.TP
MEMKIND_STAT_TYPE_ALLOCATED
Total number of allocated bytes.
.SH MEMORY STATISTICS PRINT OPTIONS
.PP
The available options for printing statistics:
.TP
MEMKIND_STAT_PRINT_ALL
Print all statistics.
.TP
MEMKIND_STAT_PRINT_JSON_FORMAT
Print statistics in JSON format.
.TP
MEMKIND_STAT_PRINT_OMIT_GENERAL
Omit general information that never changes during execution.
.TP
MEMKIND_STAT_PRINT_OMIT_MERGED_ARENA
Omit merged arena statistics.
.TP
MEMKIND_STAT_PRINT_OMIT_DESTROYED_MERGED_ARENA
Omit destroyed merged arena statistics.
.TP
MEMKIND_STAT_PRINT_OMIT_PER_ARENA
Omit per arena statistics.
.TP
MEMKIND_STAT_PRINT_OMIT_PER_SIZE_CLASS_BINS
Omit per size class statistics for bins.
.TP
MEMKIND_STAT_PRINT_OMIT_PER_SIZE_CLASS_LARGE
Omit per size class statistics for large objects.
.TP
MEMKIND_STAT_PRINT_OMIT_MUTEX
Omit all mutex statistics.
.TP
MEMKIND_STAT_PRINT_OMIT_EXTENT
Omit extent statistics.
.SH ERRORS
.TP
\f[B]\f[CB]memkind_posix_memalign()\f[B]\f[R]
returns one of the POSIX standard error codes \f[B]EINVAL\f[R] or
\f[B]ENOMEM\f[R] as defined in the <\f[I]errno.h\f[R]> if an error
occurs (these have positive values).
If the \f[I]alignment\f[R] parameter is not a power of two or is not a
multiple of \f[I]sizeof(void\f[R])*, then \f[B]EINVAL\f[R] is returned.
If there is insufficient memory to satisfy the request then
\f[B]ENOMEM\f[R] is returned.
.PP
All functions other than \f[C]memkind_posix_memalign()\f[R] which have
an integer return type return one of the negative error codes as defined
in the <\f[I]memkind.h\f[R]> and described below.
.TP
MEMKIND_ERROR_UNAVAILABLE
Requested memory kind is not available
.TP
MEMKIND_ERROR_MBIND
Call to \f[C]mbind(2)\f[R] failed
.TP
MEMKIND_ERROR_MMAP
Call to \f[C]mmap(2)\f[R] failed
.TP
MEMKIND_ERROR_MALLOC
Call to jemalloc\[cq]s \f[C]malloc()\f[R] failed
.TP
MEMKIND_ERROR_ENVIRON
Error parsing environment variable \f[I]MEMKIND_\f[R] *
.TP
MEMKIND_ERROR_INVALID
Invalid input arguments to memkind routine
.TP
MEMKIND_ERROR_TOOMANY
Error trying to initialize more than maximum \f[B]MEMKIND_MAX_KIND\f[R]
number of kinds
.TP
MEMKIND_ERROR_BADOPS
Error memkind operation structure is missing or invalid
.TP
MEMKIND_ERROR_HUGETLB
Unable to allocate huge pages
.TP
MEMKIND_ERROR_MEMTYPE_NOT_AVAILABLE
Error requested memory type is not available
.TP
MEMKIND_ERROR_OPERATION_FAILED
Error memkind operation failed
.TP
MEMKIND_ERROR_ARENAS_CREATE
Call to jemalloc\[cq]s arenas.create() failed
.TP
MEMKIND_ERROR_RUNTIME
Unspecified run-time error
.SH UTILS
.TP
\f[I]/usr/bin/memkind-hbw-nodes\f[R]
Prints a comma-separated list of high bandwidth nodes.
.TP
\f[I]/usr/bin/memkind-auto-dax-kmem-nodes\f[R]
Prints a comma-separated list of persistent memory NUMA nodes, which are
automatically detected.
.SH ENVIRONMENT
.TP
MEMKIND_HBW_NODES
This environment variable is a comma-separated list of NUMA nodes that
are treated as high bandwidth.
Uses the \f[I]libnuma\f[R] routine \f[C]numa_parse_nodestring()\f[R] for
parsing, so the syntax described in the \f[B]numa\f[R](3) man page for
this routine applies: e.g.\ 1-3,5 is a valid setting.
.TP
MEMKIND_HBW_THRESHOLD
This environment variable is bandwidth in MB/s that is the threshold for
identifying high bandwidth memory.
The default threshold is 204800 (200 GB/s), which is used if this
variable is not set.
When set, it must be greater than or equal to 0.
.TP
MEMKIND_DAX_KMEM_NODES
This environment variable is a comma-separated list of NUMA nodes that
are treated as PMEM memory.
Uses the \f[I]libnuma\f[R] routine \f[C]numa_parse_nodestring()\f[R] for
parsing, so the syntax described in the \f[B]numa\f[R](3) man page for
this routine applies: e.g.\ 1-3,5 is a valid setting.
.TP
MEMKIND_ARENA_NUM_PER_KIND
This environment variable allows leveraging internal mechanism of the
library for setting number of arenas per kind.
Value should be a positive integer (not greater than \f[B]INT_MAX\f[R]
defined in the <\f[I]limits.h\f[R]>).
The user should set the value based on the characteristics of the
application that is using the library.
Higher value can provide better performance in extremely multithreaded
applications at the cost of memory overhead.
See section \f[B]IMPLEMENTATION NOTES\f[R] of \f[B]jemalloc\f[R](3) for
more details about arenas.
.TP
MEMKIND_HOG_MEMORY
Controls behavior of memkind with regards to returning memory to the
underlying OS.
Setting \f[B]MEMKIND_HOG_MEMORY\f[R] to 1 causes memkind to not release
memory to the OS in anticipation of memory reuse soon.
This will improve latency of \[cq]free\[cq] operations but increase
memory usage.
\f[B]Note:\f[R] For file-backed kind memory will be released to the OS
only after calling \f[C]memkind_destroy_kind()\f[R], not after
\[cq]free\[cq] operations.
In context of \f[B]MEMKIND_MEM_USAGE_POLICY_CONSERVATIVE\f[R] memory
usage policy - it will also impact memory coalescing and results that
block pages will be often reused (better memory usage at the cost of
performance).
.TP
MEMKIND_DEBUG
Controls logging mechanism in memkind.
Setting \f[B]MEMKIND_DEBUG\f[R] to 1 enables printing messages like
errors and general information about the environment to the stderr.
.TP
MEMKIND_BACKGROUND_THREAD_LIMIT
Enable background worker threads.
The Value should be in the 0 to the maximum number of cpus range.
Setting \f[B]MEMKIND_BACKGROUND_THREAD_LIMIT\f[R] to the specific value
will limit the maximum number of background worker threads to this
value.
Value 0 means the maximum number of background worker threads will be
limited to the maximum number of cpus.
.TP
MEMKIND_HEAP_MANAGER
Controls heap management behavior in the memkind library by switching to
one of the available heap managers.
.PP
Values:
.IP \[bu] 2
JEMALLOC - sets the jemalloc heap manager
.IP \[bu] 2
TBB - sets the Intel Threading Building Blocks heap manager.
This option requires installed Intel Threading Building Blocks library.
.PP
If the \f[B]MEMKIND_HEAP_MANAGER\f[R] is not set then the jemalloc heap
manager will be used by default.
.SH SYSTEM CONFIGURATION
.PP
Interfaces for obtaining 2MB (HUGETLB) memory need allocated huge pages
in the kernel\[cq]s huge page pool.
.TP
HUGETLB (huge pages)
Current number of \[lq]persistent\[rq] huge pages can be read from the
\f[I]/proc/sys/vm/nr_hugepages\f[R] file.
Proposed way of setting hugepages is:
\f[C]sudo sysctl vm.nr_hugepages=<number_of_hugepages>\f[R].
More information can be found
here (https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt)
.PP
Interfaces for obtaining locality information are provided by
\f[I]libhwloc\f[R] dependency.
Functionality based on locality requires that the memkind library is
configured and built with the support of the
\f[I]libhwloc\f[R] (https://www.open-mpi.org/projects/hwloc) :
.PD 0
.P
.PD
\f[C]./configure --enable-hwloc\f[R]
.PP
Interfaces for obtaining memory performance characteristics information
are based on the \f[I]HMAT\f[R] (Heterogeneous Memory Attribute Table)
https://uefi.org/sites/default/files/resources/ACPI_6_3_final_Jan30.pdf
Functionality based on memory performance characteristics requires that
the platform configuration fully supports \f[I]HMAT\f[R] and the memkind
library is configured and built with the support of the
\f[I]libhwloc\f[R] (https://www.open-mpi.org/projects/hwloc) :
.PD 0
.P
.PD
\f[C]./configure --enable-hwloc\f[R]
.PP
\f[B]Note:\f[R] For a given target NUMA Node, the OS exposes only the
performance characteristics of the best performing NUMA node.
.SH STATIC LINKING
.PP
When linking statically against memkind, \f[I]libmemkind.a\f[R] should
be used together with its dependencies \f[I]libnuma\f[R] and
\f[I]pthread\f[R].
\f[I]Pthread\f[R] can be linked by adding
\f[I]/usr/lib64/libpthread.a\f[R] as a dependency (exact path may vary).
Typically \f[I]libnuma\f[R] will need to be compiled from sources to use
it as a static dependency.
\f[I]libnuma\f[R] can be reached on
GitHub (https://github.com/numactl/numactl)
.SH KNOWN ISSUES
.TP
HUGETLB (huge pages)
There might be some overhead in huge pages consumption caused by heap
management.
If your allocation fails because of OOM, please try to allocate extra
huge pages (e.g.\ 8 huge pages).
.SH COPYRIGHT
.PP
Copyright (C) 2014 - 2023 Intel Corporation.
All rights reserved.
.SH SEE ALSO
.PP
\f[B]malloc\f[R](3), \f[B]malloc_usable_size\f[R](3), \f[B]numa\f[R](3),
\f[B]hwloc\f[R](3), \f[B]numactl\f[R](8), \f[B]mbind\f[R](2),
\f[B]mmap\f[R](2), \f[B]jemalloc\f[R](3), \f[B]memkind_dax_kmem\f[R](3),
\f[B]memkind_default\f[R](3), \f[B]memkind_arena\f[R](3),
\f[B]memkind_fixed\f[R](3), \f[B]memkind_hbw\f[R](3),
\f[B]memkind_hugetlb\f[R](3), \f[B]memkind_pmem\f[R](3),
\f[B]syscall\f[R](2), \f[B]write\f[R](2)
