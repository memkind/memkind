.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "MEMKIND_DEFAULT" "3" "2022-11-02" "MEMKIND_DEFAULT | MEMKIND Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-2-Clause
.\" Copyright "2014-2022", Intel Corporation
.SH NAME
.PP
\f[B]memkind_default\f[R] - default implementations for memkind
operations.
.PP
\f[B]Note:\f[R] This is EXPERIMENTAL API.
The functionality and the header file itself can be changed (including
non-backward compatible changes), or removed.
.SH SYNOPSIS
.IP
.nf
\f[C]
int memkind_default_create(struct memkind *kind, struct memkind_ops *ops, const char *name);
int memkind_default_destroy(struct memkind *kind);
void *memkind_default_malloc(struct memkind *kind, size_t size);
void *memkind_default_calloc(struct memkind *kind, size_t num, size_t size);
int memkind_default_posix_memalign(struct memkind *kind, void **memptr, size_t alignment, size_t size);
void *memkind_default_realloc(struct memkind *kind, void *ptr, size_t size);
void memkind_default_free(struct memkind *kind, void *ptr);
void *memkind_default_mmap(struct memkind *kind, void *addr, size_t size);
int memkind_default_mbind(struct memkind *kind, void *ptr, size_t len);
int memkind_default_get_mmap_flags(struct memkind *kind, int *flags);
int memkind_default_get_mbind_mode(struct memkind *kind, int *mode);
size_t memkind_default_malloc_usable_size(struct memkind *kind, void *ptr);
int memkind_preferred_get_mbind_mode(struct memkind *kind, int *mode);
int memkind_interleave_get_mbind_mode(struct memkind *kind, int *mode);
int memkind_nohugepage_madvise(struct memkind *kind, void *addr, size_t size);
int memkind_posix_check_alignment(struct memkind *kind, size_t alignment);
int memkind_default_get_mbind_nodemask(struct memkind *kind, unsigned long *nodemask, unsigned long maxnode);
void memkind_default_init_once(void);
bool size_out_of_bounds(size_t size);
\f[R]
.fi
.SH DESCRIPTION
.PP
Default implementations for memkind operations which include a several
useful methods that are not part of the \f[B]MEMKIND_DEFAULT\f[R] kind
which is a fall through to the jemalloc implementation.
.TP
\f[B]\f[CB]memkind_default_create()\f[B]\f[R]
implements the required start up for every kind.
If a kind does not point to this function directly for its
\f[C]ops.create()\f[R] operation, then the function that it points to
must call \f[C]memkind_default_create()\f[R] at its start.
.TP
\f[B]\f[CB]memkind_default_destroy()\f[B]\f[R]
implements the required shutdown for every kind.
If a kind does not point to this function directly for its
\f[C]ops.destroy()\f[R] operation, then the function that it points to
must call \f[C]memkind_default_destroy()\f[R] at its end.
.TP
\f[B]\f[CB]memkind_default_malloc()\f[B]\f[R]
is a direct call through the jemalloc\[cq]s \f[C]malloc()\f[R].
.TP
\f[B]\f[CB]memkind_default_calloc()\f[B]\f[R]
is a direct call through the jemalloc\[cq]s \f[C]calloc()\f[R].
.TP
\f[B]\f[CB]memkind_default_posix_memalign()\f[B]\f[R]
is a direct call through the jemalloc\[cq]s \f[C]posix_memalign()\f[R].
.TP
\f[B]\f[CB]memkind_default_realloc()\f[B]\f[R]
is a direct call through the jemalloc\[cq]s \f[C]realloc()\f[R].
.TP
\f[B]\f[CB]memkind_default_free()\f[B]\f[R]
is a direct call through the jemalloc\[cq]s \f[C]free()\f[R].
Note that this method can be called on any pointer returned by a
jemalloc allocation, and in particular, all of the arena allocations
described in \f[B]memkind_arena\f[R](3) can use this function for
freeing.
.TP
\f[B]\f[CB]memkind_default_mmap()\f[B]\f[R]
This calls the ops->\f[C]get_mmap_flags()\f[R] operations for the kind,
or falls back on the default implementations if the function pointers
are \f[I]NULL\f[R].
The results of these calls are passed to the \f[B]mmap\f[R](2) call to
allocate pages from the operating system.
The addr is the hint passed through to mmap(2) and \f[I]size\f[R] is the
size of the buffer to be allocated.
The return value is the allocated buffer or \f[B]MAP_FAILED\f[R] in the
case of an error.
.TP
\f[B]\f[CB]memkind_default_mbind()\f[B]\f[R]
makes calls the kind\[cq]s \f[C]ops.get_mbind_nodemask()\f[R] and
\f[C]ops.get_mbind_mode()\f[R] operations to gather inputs and then
calls the \f[B]mbind\f[R](2) system call using the results along with
and user input \f[I]ptr\f[R] and \f[I]len\f[R].
.TP
\f[B]\f[CB]memkind_default_get_mmap_flags()\f[B]\f[R]
sets \f[I]flags\f[R] to \f[B]MAP_PRIVATE | MAP_ANONYMOUS\f[R].
See \f[B]mmap\f[R](2) for more information about these flags.
.TP
\f[B]\f[CB]memkind_default_get_mbind_mode()\f[B]\f[R]
sets \f[I]mode\f[R] to \f[B]MPOL_BIND\f[R].
See \f[B]mbind\f[R](2) for more information about this flag.
.TP
\f[B]\f[CB]memkind_default_malloc_usable_size()\f[B]\f[R]
is a direct call through the jemalloc\[cq]s
\f[C]malloc_usable_size()\f[R].
.TP
\f[B]\f[CB]memkind_preferred_get_mbind_mode()\f[B]\f[R]
sets \f[I]mode\f[R] to \f[B]MPOL_PREFERRED\f[R].
See \f[B]mbind\f[R](2) for more information about this flag.
.TP
\f[B]\f[CB]memkind_interleave_get_mbind_mode()\f[B]\f[R]
sets \f[I]mode\f[R] to \f[B]MPOL_INTERLEAVE\f[R].
See \f[B]mbind\f[R](2) for more information about this flag.
.TP
\f[B]\f[CB]memkind_nohugepage_madvise()\f[B]\f[R]
calls \f[B]madvise\f[R](2) with the \f[B]MADV_NOHUGEPAGE advice\f[R].
See \f[B]madvise\f[R](2) for more information about this option.
.TP
\f[B]\f[CB]memkind_posix_check_alignment()\f[B]\f[R]
can be used to check the alignment value for
\f[C]memkind_posix_memalign()\f[R] to ensure that is abides by the POSIX
requirements: alignment must be a power of 2 at least as large as
\f[C]sizeof(void*)\f[R].
.TP
\f[B]\f[CB]memkind_default_get_mbind_nodemask()\f[B]\f[R]
wraps jemalloc\[cq]s \f[B]copy_bitmask_to_bitmask\f[R].
This function copies body of the bitmask structure into passed pointer.
.TP
\f[B]\f[CB]memkind_default_init_once()\f[B]\f[R]
initializes heap manager.
.TP
\f[B]\f[CB]size_out_of_bounds()\f[B]\f[R]
returns true if given size is out of bounds, otherwise will return
false.
.SH COPYRIGHT
.PP
Copyright (C) 2014 - 2022 Intel Corporation.
All rights reserved.
.SH SEE ALSO
.PP
\f[B]memkind\f[R](3), \f[B]memkind_arena\f[R](3),
\f[B]memkind_hbw\f[R](3), \f[B]memkind_hugetlb\f[R](3),
\f[B]memkind_pmem\f[R](3), \f[B]jemalloc\f[R](3), \f[B]mbind\f[R](2),
\f[B]mmap\f[R](2)
