.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "MEMKIND_PMEM" "3" "2022-10-27" "MEMKIND_PMEM | MEMKIND Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-2-Clause
.\" Copyright "2014-2022", Intel Corporation
.SH NAME
.PP
\f[B]memkind_pmem\f[R] - file-backed memory memkind operations.
.PP
\f[B]Note:\f[R] This is EXPERIMENTAL API.
The functionality and the header file itself can be changed (including
non-backward compatible changes) or removed.
.SH SYNOPSIS
.IP
.nf
\f[C]
int memkind_pmem_create(struct memkind *kind, struct memkind_ops *ops, const char *name);
int memkind_pmem_destroy(struct memkind *kind);
void *memkind_pmem_mmap(struct memkind *kind, void *addr, size_t size);
int memkind_pmem_get_mmap_flags(struct memkind *kind, int *flags);
int memkind_pmem_validate_dir(const char *dir);
\f[R]
.fi
.SH DESCRIPTION
.PP
The pmem memory memkind operations enable memory kinds built on
memory-mapped files.
These support traditional volatile memory allocation in a fashion
similar to \f[B]libvmem\f[R](3) library.
It uses the \f[B]mmap\f[R](2) system call to create a pool of volatile
memory.
Such memory may have different attributes, depending on the file system
containing the memory-mapped files.
(See also http://pmem.io/pmdk/libvmem).
.PP
The pmem kinds are most useful when used with DAX (direct mapping of
persistent memory), which is memory-addressable persistent storage that
supports load/store access without being paged via the system page
cache.
A Persistent Memory-aware file system is typically used to provide this
type of access.
.PP
The most convenient way to create pmem kinds is to use
\f[C]memkind_create_pmem()\f[R] or
\f[C]memkind_create_pmem_with_config()\f[R] (see \f[B]memkind\f[R](3)).
.TP
\f[B]\f[CB]memkind_pmem_create()\f[B]\f[R]
is an implementation of the memkind \[lq]create\[rq] operation for
file-backed memory kinds.
This allocates a space for some pmem-specific metadata, then calls
\f[C]memkind_arena_create()\f[R] (see \f[B]memkind_arena\f[R](3))
.TP
\f[B]\f[CB]memkind_pmem_destroy()\f[B]\f[R]
is an implementation of the memkind \[lq]destroy\[rq] operation for
file-backed memory kinds.
This releases all of the resources allocated by
\f[C]memkind_pmem_create()\f[R] and allows the file system space to be
reclaimed.
.TP
\f[B]\f[CB]memkind_pmem_mmap()\f[B]\f[R]
allocates the file system space for a block of \f[I]size\f[R] bytes in
the memory-mapped file associated with given kind.
The \f[I]addr\f[R] hint is ignored.
The return value is the address of mapped memory region or
\f[B]MAP_FAILED\f[R] in the case of an error.
.TP
\f[B]\f[CB]memkind_pmem_get_mmap_flags()\f[B]\f[R]
sets \f[I]flags\f[R] to \f[B]MAP_SHARED\f[R].
See \f[B]mmap\f[R](2) for more information about these flags.
.TP
\f[B]\f[CB]memkind_pmem_validate_dir()\f[B]\f[R]
returns zero if file created in specified \f[I]pmem_dir\f[R] supports
DAX (direct mapping of persistent memory) or an error code from the
\f[B]ERRORS\f[R] if not.
.TP
MEMKIND_PMEM_CHUNK_SIZE
The size of the PMEM chunk size.
.SH COPYRIGHT
.PP
Copyright (C) 2014 - 2022 Intel Corporation.
All rights reserved.
.SH SEE ALSO
.PP
\f[B]memkind\f[R](3), \f[B]memkind_arena\f[R](3),
\f[B]memkind_default\f[R](3), \f[B]memkind_hbw\f[R](3),
\f[B]memkind_hugetlb\f[R](3), \f[B]libvmem\f[R](3),
\f[B]jemalloc\f[R](3), \f[B]mbind\f[R](2), \f[B]mmap\f[R](2)
