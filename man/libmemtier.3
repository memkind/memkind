.\" SPDX-License-Identifier: BSD-2-Clause
.\" Copyright (C) 2021-2022 Intel Corporation.
.\"
.TH "LIBMEMTIER C API" 3 "2022-06-23" "Intel Corporation" "LIBMEMTIER C API" \" -*- nroff -*-
.SH "NAME"
libmemtier \- memory tiering interface
.br
.BR Note:
.I memkind_memtier.h
functionality is considered as stable API (STANDARD API).
.SH "SYNOPSIS"
.B #include <memkind_memtier.h>
.sp
.B Link with -lmemkind
.sp
The API can be used either directly with the usage of C-functions or via environment variables.
See also
.B "ENVIRONMENT"
section.
.PP
.B "TIER MANAGEMENT:"
.sp
.BI "struct memtier_builder *memtier_builder_new(memtier_policy_t " "policy" );
.br
.BI "void memtier_builder_delete(struct memtier_builder " "*builder" );
.br
.BI "int memtier_builder_add_tier(struct memtier_builder " "*builder" ", memkind_t " "kind" ", unsigned " "kind_ratio" );
.br
.BI "struct memtier_memory *memtier_builder_construct_memtier_memory(struct memtier_builder " "*builder" );
.br
.BI "void memtier_delete_memtier_memory(struct memtier_memory " "*memory" );
.sp
.B "HEAP MANAGEMENT:
.br
.BI "void *memtier_malloc(struct memtier_memory " "*memory" ", size_t " "size" );
.br
.BI "void *memtier_kind_malloc(memkind_t " "kind" ", size_t " "size" );
.br
.BI "void *memtier_calloc(struct memtier_memory " "*memory" ", size_t " "num" ", size_t " "size" );
.br
.BI "void *memtier_kind_calloc(memkind_t " "kind" ", size_t " "num" ", size_t " "size" );
.br
.BI "void *memtier_realloc(struct memtier_memory " "*memory" ", void " "*ptr" ", size_t " "size" );
.br
.BI "void *memtier_kind_realloc(memkind_t " "kind" ", void " "*ptr" ", size_t " "size" );
.br
.BI "int memtier_posix_memalign(struct memtier_memory " "*memory" ", void " "**memptr" ", size_t " "alignment" ", size_t " "size" );
.br
.BI "int memtier_kind_posix_memalign(memkind_t " "kind" ", void " "**memptr" ", size_t " "alignment" ", size_t " "size" );
.br
.BI "size_t memtier_usable_size(void " "*ptr" );
.br
.BI "void memtier_free(void " "*ptr" );
.br
.BI "void memtier_kind_free(memkind_t " "kind" ", void " "*ptr" );
.br
.BI "size_t memtier_kind_allocated_size(memkind_t " "kind" );
.sp
.B "DECORATORS:"
.br
.BI "void memtier_kind_malloc_post(memkind_t " "kind" ", size_t " "size" ", void " "**result" );
.br
.BI "void memtier_kind_calloc_post(memkind_t " "kind" ", size_t " "nmemb" ", size_t " "size" ", void " "**result" );
.br
.BI "void memtier_kind_posix_memalign_post(memkind_t " "kind" ", void " "**memptr" ", size_t " "alignment" ", size_t " "size" ", int " "*err" );
.br
.BI "void memtier_kind_realloc_post(memkind_t " "*kind" ", void " "*ptr" ", size_t " "size" ", void " "**result" );
.br
.BI "void memtier_kind_free_pre(void " "**ptr" );
.br
.BI "void memtier_kind_usable_size_post(void " "**ptr" ", size_t " "size" );
.sp
.B "MEMTIER PROPERTY MANAGEMENT:
.br
.BI "int memtier_ctl_set(struct memtier_builder " "*builder" ", const char " "*name" ", const void " "*val" );
.SH "DESCRIPTION"
This library enables explicit allocation-time memory tiering.
It allows to make allocations with the usage of multiple kinds keeping a specified ratio between them.
This ratio determines how much of total allocated memory should be allocated with the usage of each kind.
.PP
.B "TIER MANAGEMENT:"
.br
The functions in this section are used to set up, create and destroy the
.I memtier_memory
object.
This object is passed as an argument to the
.BR memtier_malloc ()
group of functions.
It defines the way the allocations are distributed between different memory tiers.
.PP
.BR memtier_builder_new ()
returns a pointer to a new
.I memtier_builder
object which is used for creating the
.I memtier_memory
object,
.I policy
determines the policy of allocations distribution between tiers by the
.I memtier_memory
object.
See the
.B POLICIES
section in
.BR libmemtier (7)
for available options.
.PP
.BR memtier_builder_delete ()
deletes the
.I builder
object releasing the memory it used.
Use after the
.I memtier_memory
object is created with the function
.IR memtier_builder_construct_memtier_memory ().
.PP
.BR memtier_builder_add_tier ()
adds memory
.I kind
to the
.IR builder .
This
.I kind
defines a memory tier used in the
.B memtier_memory
object.
This function can be called more than once to create several different memory tiers.
The "weight" of the tier is determined by the
.I kind_ratio
parameter.
The higher it is relative to other tiers'
.IR kind_ratio ,
the higher the share of allocated memory on that tier, e.g. given that ratio DRAM:KMEM_DAX is 1:4:
.IP
sample allocation size: 20 GB total, 4 GB DRAM, 16 GB KMEM_DAX
.PP
.BR memtier_builder_construct_memtier_memory ()
returns a pointer to a newly allocated
.I memtier_memory
object. The
.I builder
can be safely removed after this operation using the
.BR memtier_builder_delete ()
function.
.PP
.BR memtier_delete_memtier_memory ()
deletes the
.I memory
tiering object releasing the memory it used.
.PP
.B "HEAP MANAGEMENT:
.br
The functions described in this section define a heap manager with an
interface modeled on the ISO C standard API's, except that the user
must specify either the
.I kind
of memory with the first argument to each function or the tiered
.I memory
object which defines memory tiers used for allocations.
See the
.B KINDS
section in the
.BR memkind (3)
manual for a full description of the implemented kinds.
.PP
.BR memtier_malloc ()
allocates
.I size
bytes of memory on one of memory tiers defined by the
.IR memory .
See
.BR libmemtier (7)
for further details on memory tiers.
.BR memkind_malloc ()
is used for allocations.
For further details on it's behavior see
.BR memkind (3).
.PP
.BR memtier_kind_malloc ()
is a wrapper to the
.BR memkind_malloc ()
function.
See
.BR memkind (3)
for further details.
.PP
.BR memtier_calloc ()
allocates
.I num
times
.I size
bytes of memory on one of memory tiers defined by the
.IR memory .
.BR memkind_calloc ()
is used for allocations.
For further details on it's behavior see
.BR memkind (3).
.PP
.BR memtier_kind_calloc ()
is a wrapper to the
.BR memkind_calloc ()
function.
See
.BR memkind (3)
for further details.
.PP
.BR memtier_realloc ()
changes the size of the previously allocated memory referenced by
.I ptr
to
.I size
bytes using memory from the tier on which
.I ptr
is allocated.
If
.I ptr
is
.IR NULL ,
new memory is allocated on a memory tier defined by
.IR memory .
.BR memkind_realloc ()
is used for reallocation.
See
.BR memkind (3)
for further details.
.PP
.BR memtier_kind_realloc ()
changes the size of the previously allocated memory referenced by
.I ptr
to
.I size
bytes using specific
.IR kind .
If
.I size
is equal to zero and
.I ptr
is not
.IR NULL ,
then the call is equivalent to
.IR "memkind_free(kind, ptr)"
and
.I NULL
is returned.
If
.I ptr
is
.IR NULL ,
.BR memtier_kind_malloc ()
is called to allocate new memory.
Otherwise, the
.BR memkind_realloc ()
function is used.
See
.BR memkind (3)
for further details.
.PP
.BR memtier_posix_memalign ()
is a wrapper of
.BR memkind_posix_memalign ()
with the main difference that the
.I memory
is used to determine the kind to be used for the allocation.
See
.BR memkind (3)
for further details.
.PP
.BR memtier_kind_posix_memalign ()
is a wrapper of
.BR memkind_posix_memalign ().
See
.BR memkind (3)
for further details.
.PP
.BR memtier_usable_size ()
returns the size of the block of memory allocated with the memtier API
at the address pointed by
.IR ptr .
.PP
.BR memtier_free ()
is a wrapper for the
.BR memtier_kind_free ()
function with the
.I kind
parameter passed as
.IR NULL .
.PP
.BR memtier_kind_free ()
frees up the memory pointed to by
.IR ptr .
The behavior is the same as for the
.BR memkind_free ().
If
.I kind
is
.IR NULL ,
the kind used to allocate
.I ptr
is detected automatically.
See
.BR memkind (3)
for further details.
.PP
.BR memtier_kind_allocated_size ()
returns the total size of memory allocated with the usage of
.I kind
and the memtier API.
.PP
.B "DECORATORS:"
.br
This is the set of functions used to print information on each call to the respective
.I memtier_kind_*
function described in the
.B "HEAP MANAGEMENT"
section.
Printed information include the name of the
.B kind
used, parameters passed to the underlying function from the malloc family of functions
and the address of the memory returned.
.PP
.B "MEMTIER PROPERTY MANAGEMENT:
.br
.BR memtier_ctl_set ()
is useful for changing the default values of parameters that define the
.I DYNAMIC_THRESHOLD
policy.
This function can be used in the process of creating a
.B memtier_memory
object with the usage of
.IR builder .
The parameter
.I name
can be one of the following:
.IP policy.dynamic_threshold.thresholds[ID].val
initial threshold level,
all alocations of the size below this value will come from the
.I IDth
tier,
greater than or equal to this value will come from the
.I (ID+1)th
tier.
Provided string is converted to the
.I size_t
type.
This value is modified automatically during the application run to keep the desired ratio between tiers.
The default value between first two tiers is 1024 bytes
.IP policy.dynamic_threshold.thresholds[ID].min
minimum value of the threshold level.
Provided string is converted to the
.I size_t
type.
The default value between first two tiers is 513 bytes.
.IP policy.dynamic_threshold.thresholds[ID].max
maximum value of the threshold level.
Provided string is converted to the
.I size_t
type.
The default value between first two tiers is 1536 bytes.
.IP policy.dynamic_threshold.check_cnt
number of allocation operations (i.e. malloc, realloc) after which the ratio check between tiers is performed.
Provided string is converted to the
.I "unsigned int"
type.
The default value is 20.
.IP policy.dynamic_threshold.trigger
the dynamic threshold value is adjusted when the absolute difference between current ratio and expected ratio is greater than or equal to this value.
Provided string is converted to the
.I float
type.
The default value is 0.02.
.IP policy.dynamic_threshold.degree
the threshold value is updated by increasing or decreasing it's value by
.I degree
percentage (i.e.
.IR degree =0.02
changes threshold value by 2%).
Provided string is converted to the
.I float
type.
The default value is 0.15.
.PP
In the above examples,
.I ID
should be replaced with the ID of thresholds configuration.
The configuration between first two tiers added to
.B builder
has an
.I ID
equal to 0.
The configuration
.I ID
of the next two tiers, that is, the second and third ones,
is equal to 1, and so on.
The last configuration's
.I ID
is equal to the number of tiers minus one.

.SH "ENVIRONMENT"
See
.BR libmemtier (7)
for details on the usage of memkind tiering via environment variables.

.SH "COPYRIGHT"
Copyright (C) 2021-2022 Intel Corporation. All rights reserved.
.SH "SEE ALSO"
.BR libmemtier (7),
.BR memkind (3),
.BR memkind_malloc (3),
.BR memkind_calloc (3),
.BR memkind_realloc (3),
.BR memkind_free (3),
.BR memkind_posix_memalign (3)
