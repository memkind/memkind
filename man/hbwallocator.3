.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "HBWALLOCATOR" "3" "2022-10-21" "HBWALLOCATOR | MEMKIND Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-2-Clause
.\" Copyright "2015-2022", Intel Corporation
.SH NAME
.PP
\f[B]hbw::allocator\f[R] - The C++ allocator compatible with the C++
standard library allocator concepts
.PD 0
.P
.PD
\f[B]Note:\f[R] This is EXPERIMENTAL API.
The functionality and the header file itself can be changed (including
non-backward compatible changes) or removed.
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <hbw_allocator.h>

Link with -lmemkind

hbw::allocator();
template <class U>hbw::allocator<T>::allocator(const hbw::allocator<U>&);
hbw::allocator<T>::\[ti]allocator()\[ga]
hbw::allocator<T>::pointer hbw::allocator<T>::address(hbw::allocator<T>::reference x);
hbw::allocator<T>::const_pointer hbw::allocator<T>::address(hbw::allocator<T>::const_reference x);
hbw::allocator<T>::pointer hbw::allocator<T>::allocate(hbw::allocator<T>::size_type n, const void * = 0);
void hbw::allocator<T>::deallocate(hbw::allocator<T>::pointer p, hbw::allocator<T>::size_type n);
hbw::allocator<T>::size_type hbw::allocator<T>::max_size();
void hbw::allocator<T>::construct(hbw::allocator<T>::pointer p, const hbw::allocator<T>::value_type& val);
void hbw::allocator<T>::destroy(hbw::allocator<T>::pointer p);
\f[R]
.fi
.SH DESCRIPTION
.PP
The \f[B]hbw::allocator\f[R] is intended to be used with STL containers
to allocate high bandwidth memory.
Memory management is based on hbwmalloc (\f[B]memkind\f[R] library),
enabling users to gain performance in multithreaded applications.
Refer \f[B]hbwmalloc\f[R](3) and \f[B]memkind\f[R](3) man page for more
details.
.PP
All public member types and functions corresponds to standard library
allocator concepts and definitions.
The current implementation supports the C++03 standard.
.PP
Template arguments:
.IP \[bu] 2
T is an object type aliased by value_type.
.IP \[bu] 2
U is an object type.
.PP
\f[B]Note:\f[R]
.TP
\f[B]\f[CB]hbw::allocator<T>::pointer hbw::allocator<T>::allocate(hbw::allocator<T>::size_type n, const void * = 0)\f[B]\f[R]
allocates high bandwidth memory using \f[C]hbw_malloc()\f[R].
Throw \f[C]std::bad_alloc\f[R] when:
.IP \[bu] 2
n = 0 (when \f[I]\[en]enable-malloc-nonnull\f[R] configure option is not
set),
.IP \[bu] 2
n > max_size()
.IP \[bu] 2
or there is not enough memory to satisfy the request.
.TP
\f[B]\f[CB]hbw::allocator<T>::deallocate(hbw::allocator<T>::pointer p, hbw::allocator<T>::size_type n)\f[B]\f[R]
deallocates memory associated with pointer returned by allocate() using
hbw_free().
.SH ERRORS
.PP
The same as described in \f[B]ERRORS\f[R] section of
\f[B]hbwmalloc\f[R](3) man page.
.SH NOTES
.PP
The \f[C]hbw::allocator<T>\f[R] behavior depends on hbwmalloc heap
management policy.
To get and set the policy please use \f[C]hbw_get_policy()\f[R] and
\f[C]hbw_set_policy()\f[R] respectively.
.SH COPYRIGHT
.PP
Copyright (C) 2015 - 2022 Intel Corporation.
All rights reserved.
.SH SEE ALSO
.PP
\f[B]hbwmalloc\f[R](3), \f[B]numa\f[R](3), \f[B]numactl\f[R](8),
\f[B]memkind\f[R](3)
