<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Wed Feb  3 11:22:41 2021 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MEMKINDALLOCATOR</title>

</head>
<body>

<h1 align="center">MEMKINDALLOCATOR</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SYSTEM CONFIGURATION">SYSTEM CONFIGURATION</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">libmemkind::static_kind::allocator&lt;T&gt;
- The C++ allocator compatible with the C++ standard library
allocator concepts <b><br>
Note:</b> <i>memkind_allocator.h</i> functionality is
considered as stable API (STANDARD API).</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;memkind_allocator.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Link with
-lmemkind</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::static_kind::allocator(libmemkind::kinds</b>
<i>kind</i><b>); <br>
template &lt;typename U&gt;
libmemkind::static_kind::allocator&lt;T&gt;::allocator(const
libmemkind::static_kind::allocator&lt;U&gt;&amp;) noexcept;
<br>
template &lt;typename U&gt;
libmemkind::static_kind::allocator(const
allocator&lt;U&gt;&amp;&amp;</b> <i>other</i><b>) noexcept;
<br>
libmemkind::static_kind::allocator&lt;T&gt;::~allocator();
<br>
T
*libmemkind::static_kind::allocator&lt;T&gt;::allocate(std::size_t</b>
<i>n</i><b>) const; <br>
void
libmemkind::static_kind::allocator&lt;T&gt;::deallocate(T</b>
<i>*p</i><b>, std::size_t</b> <i>n</i><b>) const; <br>
template &lt;class U, class... Args&gt; void
libmemkind::static_kind::allocator&lt;T&gt;::construct(U</b>
<i>*p</i><b>, Args...</b> <i>args</i><b>) const; <br>
void
libmemkind::static_kind::allocator&lt;T&gt;::destroy(T</b>
<i>*p</i><b>) const;</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>libmemkind::static_kind::allocator&lt;T&gt;</b> is
intended to be used with STL containers to allocate from
static kinds memory. Memory management is based on memkind
library. Refer <b>memkind</b>(3) man page for more
details.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>libmemkind::kinds</b> specifies allocator static kinds of
memory, representing type of memory which offers different
characteristics. The available types of allocator kinds of
memory:</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DEFAULT</b>
Default allocation using standard memory and default page
size.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HIGHEST_CAPACITY</b>
Allocate from a NUMA node(s) that has the highest capacity
among all nodes in the system.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HIGHEST_CAPACITY_PREFERRED</b>
Same as <b>libmemkind::kinds::HIGHEST_CAPACITY</b> except
that if there is not enough memory in the NUMA node that has
the highest capacity in the local domain to satisfy the
request, the allocation will fall back on other memory NUMA
nodes. <b>Note:</b> For this kind, the allocation will not
succeed if there are two or more NUMA nodes that have the
highest capacity.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HIGHEST_CAPACITY_LOCAL</b>
Allocate from a NUMA node(s) that has the highest capacity
among all NUMA Nodes from the local domain. NUMA Nodes have
the same local domain for a set of CPUs associated with
them, e.g. socket or sub-NUMA cluster. <b>Note:</b> This
kind requires locality information described in <b>SYSTEM
CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HIGHEST_CAPACITY_LOCAL_PREFERRED</b>
Same as <b>libmemkind::kinds::HIGHEST_CAPACITY_LOCAL</b>
except that if there is not enough memory in the NUMA node
that has the highest capacity to satisfy the request, the
allocation will fall back on other memory NUMA nodes.
<b>Note:</b> For this kind, the allocation will not succeed
if there are two or more NUMA nodes in the same local domain
that have the highest capacity.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::LOWEST_LATENCY_LOCAL</b>
Allocate from a NUMA node(s) that has the lowest latency
among all NUMA Nodes from the local domain. NUMA Nodes have
the same local domain for a set of CPUs associated with
them, e.g. socket or sub-NUMA cluster. <b>Note:</b> This
kind requires locality and memory performance
characteristics information described in <b>SYSTEM
CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::LOWEST_LATENCY_LOCAL_PREFERRED</b>
Same as <b>libmemkind::kinds::LOWEST_LATENCY_LOCAL</b>
except that if there is not enough memory in the NUMA node
that has the lowest latency to satisfy the request, the
allocation will fall back on other memory NUMA nodes.
<b>Note:</b> For this kind, the allocation will not succeed
if there are two or more NUMA nodes in the same local domain
that have the lowest latency.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HIGHEST_BANDWIDTH_LOCAL</b>
Allocate from a NUMA node(s) that has the highest bandwidth
among all NUMA Nodes from the local domain. NUMA Nodes have
the same local domain for a set of CPUs associated with
them, e.g. socket or sub-NUMA cluster. <b>Note:</b> This
kind requires locality and memory performance
characteristics information described in <b>SYSTEM
CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HIGHEST_BANDWIDTH_LOCAL_PREFERRED</b>
Same as <b>libmemkind::kinds::HIGHEST_BANDWIDTH_LOCAL</b>
except that if there is not enough memory in the NUMA node
that has the highest bandwidth to satisfy the request, the
allocation will fall back on other memory NUMA nodes.
<b>Note:</b> For this kind, the allocation will not succeed
if there are two or more NUMA nodes in the same local domain
that have the highest bandwidth.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HUGETLB</b>
Allocate from standard memory using huge pages. Note: This
kind requires huge pages configuration described in
<b>SYSTEM CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::INTERLEAVE</b>
Allocate pages interleaved across all NUMA nodes with
transparent huge pages disabled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW</b>
Allocate from the closest high bandwidth memory NUMA node at
the time of allocation. If there is not enough high
bandwidth memory to satisfy the request, errno is set to
ENOMEM and the allocated pointer is set to <i>NULL</i>.
Note: This kind requires memory performance characteristics
information described in <b>SYSTEM CONFIGURATION</b>
section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_ALL</b>
Same as <b>libmemkind::kinds::HBW</b> except decision
regarding closest NUMA node is postponed until the time of
first write.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_HUGETLB</b>
Same as <b>libmemkind::kinds::HBW</b> except the allocation
is backed by huge pages. Note: This kind requires huge pages
configuration described in <b>SYSTEM CONFIGURATION</b>
section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_ALL_HUGETLB</b>
Combination of <b>libmemkind::kinds::HBW_ALL</b> and
<b>libmemkind::kinds::HBW_HUGETLB</b> properties. Note: This
kind requires huge pages configuration described in
<b>SYSTEM CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_PREFERRED</b>
Same as <b>libmemkind::kinds::HBW</b> except that if there
is not enough high bandwidth memory to satisfy the request,
the allocation will fall back on standard memory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_PREFERRED_HUGETLB</b>
Same as <b>libmemkind::kinds::HBW_PREFERRED</b> except the
allocation is backed by huge pages. Note: This kind requires
huge pages configuration described in <b>SYSTEM
CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_INTERLEAVE</b>
Same as <b>libmemkind::kinds::HBW</b> except that the pages
that support the allocation are interleaved across all high
bandwidth nodes and transparent huge pages are disabled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::REGULAR</b>
Allocate from regular memory using the default page size.
Regular means general purpose memory from the NUMA nodes
containing CPUs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DAX_KMEM</b>
Allocate from the closest persistent memory NUMA node at the
time of allocation. If there is not enough memory in the
closest persistent memory NUMA node to satisfy the request,
<i>errno</i> is set to <b>ENOMEM</b> and the allocated
pointer is set to <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DAX_KMEM_ALL</b>
Allocate from the closest persistent memory NUMA node
available at the time of allocation. If there is not enough
memory on any of persistent memory NUMA nodes to satisfy the
request, <i>errno</i> is set to <b>ENOMEM</b> and the
allocated pointer is set to <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DAX_KMEM_PREFERRED</b>
Same as <b>libmemkind::kinds::DAX_KMEM</b> except that if
there is not enough memory in the closest persistent memory
NUMA node to satisfy the request, the allocation will fall
back on other memory NUMA nodes. <b>Note:</b> For this kind,
the allocation will not succeed if two or more persistent
memory NUMA nodes are in the same shortest distance to the
same CPU on which process is eligible to run. Check on that
eligibility is done upon starting the application.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DAX_KMEM_INTERLEAVE</b>
Same as <b>libmemkind::kinds::DAX_KMEM</b> except that the
pages that support the allocation are interleaved across all
persistent memory NUMA nodes.</p>

<p style="margin-left:11%; margin-top: 1em">All public
member types and functions correspond to standard library
allocator concepts and definitions. The current
implementation supports C++11 standard.</p>

<p style="margin-left:11%; margin-top: 1em">Template
arguments: <i><br>
T</i> is an object type aliased by value_type. <i><br>
U</i> is an object type.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note: <br>
T
*libmemkind::static_kind::allocator&lt;T&gt;::allocate(std::size_t</b>
<i>n</i><b>)</b> allocates memory using
<b>memkind_malloc</b>(). Throw <i>std::bad_alloc</i>
when:</p>

<p style="margin-left:22%;"><i>n</i> = 0 <br>
or there is not enough memory to satisfy the request.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::static_kind::allocator&lt;T&gt;::deallocate(T</b>
<i>*p</i><b>, std::size_t</b> <i>n</i><b>)</b> deallocates
memory associated with pointer returned by <b>allocate</b>()
using <b>memkind_free</b>().</p>

<h2>SYSTEM CONFIGURATION
<a name="SYSTEM CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining 2MB (HUGETLB) memory need allocated huge pages in
the kernel&rsquo;s huge page pool. <b><br>
HUGETLB (huge pages)</b></p>

<p style="margin-left:22%;">Current number of
&quot;persistent&quot; huge pages can be read from
<i>/proc/sys/vm/nr_hugepages</i> file. Proposed way of
setting hugepages is: <b>sudo sysctl
vm.nr_hugepages=&lt;number_of_hugepages&gt;</b>. More
information can be found here:
<a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</a></p>

<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining locality information are provided by
<i>libhwloc</i> dependency. Functionality based on locality
requires that memkind library is configured and built with
the support of <i>libhwloc</i> (./configure
--enable-hwloc).</p>

<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining memory performance characteristics information are
based on <i>HMAT</i> (Heterogeneous Memory Attribute Table)
<a href="https://uefi.org/sites/default/files/resources/ACPI_6_3_final_Jan30.pdf">https://uefi.org/sites/default/files/resources/ACPI_6_3_final_Jan30.pdf</a>
Functionality based on memory performance characteristics
requires that platform configuration fully supports HMAT and
memkind library is configured and built with the support of
<i>libhwloc</i> (./configure --enable-hwloc).</p>


<p style="margin-left:11%; margin-top: 1em"><i>libhwloc</i>
can be reached on:
<a href="https://www.open-mpi.org/projects/hwloc">https://www.open-mpi.org/projects/hwloc</a></p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2019 - 2021 Intel Corporation. All rights reserved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind</b>(3)</p>
<hr>
</body>
</html>
