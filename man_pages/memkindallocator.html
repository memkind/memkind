<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Wed Sep 16 10:45:04 2020 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MEMKINDALLOCATOR</title>

</head>
<body>

<h1 align="center">MEMKINDALLOCATOR</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SYSTEM CONFIGURATION">SYSTEM CONFIGURATION</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">libmemkind::static_kind::allocator&lt;T&gt;
- The C++ allocator compatible with the C++ standard library
allocator concepts <b><br>
Note:</b> <i>memkind_allocator.h</i> functionality is
considered as stable API (STANDARD API).</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;memkind_allocator.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Link with
-lmemkind</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::static_kind::allocator(libmemkind::kinds</b>
<i>kind</i><b>); <br>
template &lt;typename U&gt;
libmemkind::static_kind::allocator&lt;T&gt;::allocator(const
libmemkind::static_kind::allocator&lt;U&gt;&amp;) noexcept;
<br>
template &lt;typename U&gt;
libmemkind::static_kind::allocator(const
allocator&lt;U&gt;&amp;&amp;</b> <i>other</i><b>) noexcept;
<br>
libmemkind::static_kind::allocator&lt;T&gt;::~allocator();
<br>
T
*libmemkind::static_kind::allocator&lt;T&gt;::allocate(std::size_t</b>
<i>n</i><b>) const; <br>
void
libmemkind::static_kind::allocator&lt;T&gt;::deallocate(T</b>
<i>*p</i><b>, std::size_t</b> <i>n</i><b>) const; <br>
template &lt;class U, class... Args&gt; void
libmemkind::static_kind::allocator&lt;T&gt;::construct(U</b>
<i>*p</i><b>, Args...</b> <i>args</i><b>) const; <br>
void
libmemkind::static_kind::allocator&lt;T&gt;::destroy(T</b>
<i>*p</i><b>) const;</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>libmemkind::static_kind::allocator&lt;T&gt;</b> is
intended to be used with STL containers to allocate from
static kinds memory. Memory management is based on memkind
library. Refer <b>memkind</b>(3) man page for more
details.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>libmemkind::kinds</b> specifies allocator static kinds of
memory, representing type of memory which offers different
characteristics. The available types of allocator kinds of
memory:</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DEFAULT</b>
Default allocation using standard memory and default page
size.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HUGETLB</b>
Allocate from standard memory using huge pages. Note: This
kind requires huge pages configuration described in
<b>SYSTEM CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::INTERLEAVE</b>
Allocate pages interleaved across all NUMA nodes with
transparent huge pages disabled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW</b>
Allocate from the closest high bandwidth memory NUMA node at
the time of allocation. If there is not enough high
bandwidth memory to satisfy the request, errno is set to
ENOMEM and the allocated pointer is set to <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_ALL</b>
Same as <b>libmemkind::kinds::HBW</b> except decision
regarding closest NUMA node is postponed until the time of
first write.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_HUGETLB</b>
Same as <b>libmemkind::kinds::HBW</b> except the allocation
is backed by huge pages. Note: This kind requires huge pages
configuration described in <b>SYSTEM CONFIGURATION</b>
section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_ALL_HUGETLB</b>
Combination of <b>libmemkind::kinds::HBW_ALL</b> and
<b>libmemkind::kinds::HBW_HUGETLB</b> properties. Note: This
kind requires huge pages configuration described in
<b>SYSTEM CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_PREFERRED</b>
Same as <b>libmemkind::kinds::HBW</b> except that if there
is not enough high bandwidth memory to satisfy the request,
the allocation will fall back on standard memory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_PREFERRED_HUGETLB</b>
Same as <b>libmemkind::kinds::HBW_PREFERRED</b> except the
allocation is backed by huge pages. Note: This kind requires
huge pages configuration described in <b>SYSTEM
CONFIGURATION</b> section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::HBW_INTERLEAVE</b>
Same as <b>libmemkind::kinds::HBW</b> except that the pages
that support the allocation are interleaved across all high
bandwidth nodes and transparent huge pages are disabled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::REGULAR</b>
Allocate from regular memory using the default page size.
Regular means general purpose memory from the NUMA nodes
containing CPUs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DAX_KMEM</b>
Allocate from the closest persistent memory NUMA node at the
time of allocation. If there is not enough memory in the
closest persistent memory NUMA node to satisfy the request,
<i>errno</i> is set to <b>ENOMEM</b> and the allocated
pointer is set to <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DAX_KMEM_ALL</b>
Allocate from the closest persistent memory NUMA node
available at the time of allocation. If there is not enough
memory on any of persistent memory NUMA nodes to satisfy the
request, <i>errno</i> is set to <b>ENOMEM</b> and the
allocated pointer is set to <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::kinds::DAX_KMEM_PREFERRED</b>
Same as <b>libmemkind::kinds::DAX_KMEM</b> except that if
there is not enough memory in the closest persistent memory
NUMA node to satisfy the request, the allocation will fall
back on other memory NUMA nodes. <b>Note:</b> For this kind,
the allocation will not succeed if two or more persistent
memory NUMA nodes are in the same shortest distance to the
same CPU on which process is eligible to run. Check on that
eligibility is done upon starting the application.</p>

<p style="margin-left:11%; margin-top: 1em">All public
member types and functions correspond to standard library
allocator concepts and definitions. The current
implementation supports C++11 standard.</p>

<p style="margin-left:11%; margin-top: 1em">Template
arguments: <i><br>
T</i> is an object type aliased by value_type. <i><br>
U</i> is an object type.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note: <br>
T
*libmemkind::static_kind::allocator&lt;T&gt;::allocate(std::size_t</b>
<i>n</i><b>)</b> allocates memory using
<b>memkind_malloc</b>(). Throw <i>std::bad_alloc</i>
when:</p>

<p style="margin-left:22%;"><i>n</i> = 0 <br>
or there is not enough memory to satisfy the request.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libmemkind::static_kind::allocator&lt;T&gt;::deallocate(T</b>
<i>*p</i><b>, std::size_t</b> <i>n</i><b>)</b> deallocates
memory associated with pointer returned by <b>allocate</b>()
using <b>memkind_free</b>().</p>

<h2>SYSTEM CONFIGURATION
<a name="SYSTEM CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining 2MB (HUGETLB) memory need allocated huge pages in
the kernel&rsquo;s huge page pool. <b><br>
HUGETLB (huge pages)</b></p>

<p style="margin-left:22%;">Current number of
&quot;persistent&quot; huge pages can be read from
<i>/proc/sys/vm/nr_hugepages</i> file. Proposed way of
setting hugepages is: <b>sudo sysctl
vm.nr_hugepages=&lt;number_of_hugepages&gt;</b>. More
information can be found here:
<a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</a></p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2019 - 2020 Intel Corporation. All rights reserved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind</b>(3)</p>
<hr>
</body>
</html>
