<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Mon Dec 16 14:25:47 2019 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MEMKIND</title>

</head>
<body>

<h1 align="center">MEMKIND</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#KINDS">KINDS</a><br>
<a href="#MEMORY TYPES">MEMORY TYPES</a><br>
<a href="#MEMORY BINDING POLICY">MEMORY BINDING POLICY</a><br>
<a href="#MEMORY FLAGS">MEMORY FLAGS</a><br>
<a href="#MEMORY USAGE POLICY">MEMORY USAGE POLICY</a><br>
<a href="#MEMORY STATISTICS TYPE">MEMORY STATISTICS TYPE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#SYSTEM CONFIGURATION">SYSTEM CONFIGURATION</a><br>
<a href="#STATIC LINKING">STATIC LINKING</a><br>
<a href="#KNOWN ISSUES">KNOWN ISSUES</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">memkind - Heap
manager that enables allocations to memory with different
properties. <br>
This header expose STANDARD and EXPERIMENTAL API. API
Standards are described below in this man page.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;memkind.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Link with
-lmemkind</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>EXPERIMENTAL
API: <br>
HEAP MANAGEMENT: <br>
int memkind_posix_memalign(memkind_t</b> <i>kind</i><b>,
void</b> <i>**memptr</i><b>, size_t</b> <i>alignment</i><b>,
size_t</b> <i>size</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
MANAGEMENT: <br>
int memkind_create_kind(memkind_memtype_t</b>
<i>memtype_flags</i><b>, memkind_policy_t</b>
<i>policy</i><b>, memkind_bits_t</b> <i>flags</i><b>,
memkind_t</b> <i>*kind</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>STANDARD
API: <br>
ERROR HANDLING: <br>
void memkind_error_message(int</b> <i>err</i><b>, char</b>
<i>*msg</i><b>, size_t</b> <i>size</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>LIBRARY
VERSION: <br>
int memkind_get_version();</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>HEAP
MANAGEMENT: <br>
void *memkind_malloc(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>size</i><b>); <br>
void *memkind_calloc(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>num</i><b>, size_t</b> <i>size</i><b>); <br>
void *memkind_realloc(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>, size_t</b> <i>size</i><b>); <br>
void memkind_free(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>); <br>
size_t memkind_malloc_usable_size(memkind_t</b>
<i>kind</i><b>, void</b> <i>*ptr</i><b>); <br>
void *memkind_defrag_reallocate(memkind_t</b>
<i>kind</i><b>, void</b> <i>*ptr</i><b>); <br>
memkind_t memkind_detect_kind(void</b>
<i>*ptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
CONFIGURATION MANAGEMENT: <br>
struct memkind_config *memkind_config_new(); <br>
void memkind_config_delete(struct memkind_config</b>
<i>*cfg</i><b>); <br>
void memkind_config_set_path(struct memkind_config</b>
<i>*cfg</i><b>, const char</b> <i>*pmem_dir</i><b>); <br>
void memkind_config_set_size(struct memkind_config</b>
<i>*cfg</i><b>, size_t</b> <i>pmem_size</i><b>); <br>
void memkind_config_set_memory_usage_policy(struct
memkind_config</b> <i>*cfg</i><b>,
memkind_mem_usage_policy</b> <i>policy</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
MANAGEMENT: <br>
int memkind_create_pmem(const char</b> <i>*dir</i><b>,
size_t</b> <i>max_size</i><b>, memkind_t</b>
<i>*kind</i><b>); <br>
int memkind_create_pmem_with_config(struct
memkind_config</b> <i>*cfg</i><b>, memkind_t</b>
<i>*kind</i><b>); <br>
int memkind_destroy_kind(memkind_t</b> <i>kind</i><b>); <br>
int memkind_check_available(memkind_t</b>
<i>kind</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>STATISTICS:
<br>
int memkind_update_cached_stats(void); <br>
int memkind_get_stat(memkind_t</b> <i>kind</i><b>,
memkind_stat</b> <i>stat</i><b>, size_t</b>
<i>*value</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>DECORATORS:
<br>
void memkind_malloc_pre(memkind_t</b> <i>*kind</i><b>,
size_t</b> <i>*size</i><b>); <br>
void memkind_malloc_post(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>size</i><b>, void</b> <i>**result</i><b>);
<br>
void memkind_calloc_pre(memkind_t</b> <i>*kind</i><b>,
size_t</b> <i>*nmemb</i><b>, size_t</b> <i>*size</i><b>);
<br>
void memkind_calloc_post(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>nmemb</i><b>, size_t</b> <i>size</i><b>,
void</b> <i>**result</i><b>); <br>
void memkind_posix_memalign_pre(memkind_t</b>
<i>*kind</i><b>, void</b> <i>**memptr</i><b>, size_t</b>
<i>*alignment</i><b>, size_t</b> <i>*size</i><b>); <br>
void memkind_posix_memalign_post(memkind_t</b>
<i>kind</i><b>, void</b> <i>**memptr</i><b>, size_t</b>
<i>alignment</i><b>, size_t</b> <i>size</i><b>, int</b>
<i>*err</i><b>); <br>
void memkind_realloc_pre(memkind_t</b> <i>*kind</i><b>,
void</b> <i>**ptr</i><b>, size_t</b> <i>*size</i><b>); <br>
void memkind_realloc_post(memkind_t</b> <i>*kind</i><b>,
void</b> <i>*ptr</i><b>, size_t</b> <i>size</i><b>, void</b>
<i>**result</i><b>); <br>
void memkind_free_pre(memkind_t</b> <i>*kind</i><b>,
void</b> <i>**ptr</i><b>); <br>
void memkind_free_post(memkind_t</b> <i>kind</i><b>,
void</b> <i>*ptr</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_error_message</b>()
converts an error number <i>err</i> returned by a member of
the memkind interface to an error message <i>msg</i> where
the maximum size of the message is passed by the <i>size</i>
parameter.</p>

<p style="margin-left:11%; margin-top: 1em"><b>HEAP
MANAGEMENT:</b> <br>
The functions described in this section define a heap
manager with an interface modeled on the ISO C standard
API&rsquo;s, except that the user must specify the
<i>kind</i> of memory with the first argument to each
function. See the <b>KINDS</b> section below for a full
description of the implemented kinds. For file-backed kind
of memory see <b>memkind_create_pmem</b>() or
<b>memkind_create_pmem_with_config</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_malloc</b>()
allocates <i>size</i> bytes of uninitialized memory of the
specified <i>kind</i>. The allocated space is suitably
aligned (after possible pointer coercion) for storage of any
type of object. If <i>size</i> is 0, then
<b>memkind_malloc</b>() returns <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_calloc</b>()
allocates space for <i>num</i> objects each <i>size</i>
bytes in length in memory of the specified <i>kind</i>. The
result is identical to calling <b>memkind_malloc</b>() with
an argument of <i>num</i> * <i>size</i>, with the exception
that the allocated memory is explicitly initialized to zero
bytes. If <i>num</i> or <i>size</i> is 0, then
<b>memkind_calloc</b>() returns <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_realloc</b>()
changes the size of the previously allocated memory
referenced by <i>ptr</i> to <i>size</i> bytes of the
specified <i>kind</i>. The contents of the memory remain
unchanged up to the lesser of the new and old sizes. If the
new size is larger, the contents of the newly allocated
portion of the memory are undefined. Upon success, the
memory referenced by <i>ptr</i> is freed and a pointer to
the newly allocated memory is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
memkind_realloc</b>() may move the memory allocation,
resulting in a different return value than <i>ptr</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>ptr</i>
is <i>NULL</i>, the <b>memkind_realloc</b>() function
behaves identically to <b>memkind_malloc</b>() for the
specified size. If <i>size</i> is equal to zero, and
<i>ptr</i> is not <i>NULL</i>, then the call is equivalent
to <i>memkind_free(kind, ptr)</i> and <i>NULL</i> is
returned. The address <i>ptr</i>, if not <i>NULL</i>, must
have been returned by a previous call to
<b>memkind_malloc</b>(), <b>memkind_calloc</b>(),
<b>memkind_realloc</b>(), <b>memkind_defrag_reallocate</b>()
or <b>memkind_posix_memalign</b>() with the same <i>kind</i>
as specified to the call to <b>memkind_realloc</b>().
Otherwise, if <i>memkind_free(kind, ptr)</i> was called
before, undefined behavior occurs. In cases where the kind
is unknown in the context of the call to
<b>memkind_realloc</b>() <i>NULL</i>, can be given as the
<i>kind</i> specified to <b>memkind_realloc</b>(), but this
will require a internal look up for correct kind.
<b>Note:</b> The look up for <i>kind</i> could result in
serious performance penalty, which can be avoided by
specifying a correct <i>kind</i>. If <i>kind</i> is
<i>NULL</i> and <i>ptr</i> is <i>NULL</i>, then
<b>memkind_realloc</b>() returns <i>NULL</i> and sets
<i>errno</i> to <b>EINVAL</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_posix_memalign</b>()
allocates <i>size</i> bytes of memory of a specified
<i>kind</i> such that the allocation&rsquo;s base address is
an even multiple of <i>alignment</i>, and returns the
allocation in the value pointed to by <i>memptr</i>. The
requested <i>alignment</i> must be a power of 2 at least as
large as <i>sizeof(void*)</i>. If <i>size</i> is 0, then
<b>memkind_posix_memalign</b>() returns 0, with a
<i>NULL</i> returned in <i>memptr</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_malloc_usable_size</b>()
function provides the same semantics as
<b>malloc_usable_size</b>(3), but operates on specified
<i>kind</i>. <b><br>
Note:</b> In cases where the kind is unknown in the context
of the call to <b>memkind_malloc_usable_size</b>()
<i>NULL</i>, can be given as the <i>kind</i> specified to
<b>memkind_malloc_usable_size</b>(), but this could require
a internal look up for correct kind.
<b>memkind_malloc_usable_size</b>() is supported by TBB heap
manager described in <b>ENVIRONMENT</b> section since Intel
TBB 2019 Update 4.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_defrag_reallocate</b>()
reallocates the object conditonally inside specific
<i>kind</i>. Function determines if it&rsquo;s worthwhile to
move allocation to reduce degree of external fragmentation
of the heap. In case of failure function returns
<i>NULL</i>, otherwise function returns a pointer to
reallocated memory and memory referenced by <i>ptr</i> was
released and should not be accessed. If <i>ptr</i> is
<i>NULL</i>, then <b>memkind_defrag_reallocate</b>() returns
<i>NULL</i>. <i>NULL</i>, can be given as the <i>kind</i>
specified to <b>memkind_defrag_reallocate</b>(), but this
will require a internal look up for correct kind.
<b>Note:</b> The look up for <i>kind</i> could result in
serious performance penalty, which can be avoided by
specifying a correct <i>kind</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_detect_kind</b>()
returns the kind associated with allocated memory referenced
by <i>ptr</i>. This pointer must have been returned by a
previous call to <b>memkind_malloc</b>(),
<b>memkind_calloc</b>(), <b>memkind_realloc</b>(),
<b>memkind_defrag_reallocate</b>() or
<b>memkind_posix_memalign</b>(). If <i>ptr</i> is
<i>NULL</i>, then <b>memkind_detect_kind</b>() returns
<i>NULL</i>. <b>Note:</b> This function has non-trivial
performance overhead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_free</b>()
causes the allocated memory referenced by <i>ptr</i> to be
made available for future allocations. This pointer must
have been returned by a previous call to
<b>memkind_malloc</b>(), <b>memkind_calloc</b>(),
<b>memkind_realloc</b>(), <b>memkind_defrag_reallocate</b>()
or <b>memkind_posix_memalign</b>(). Otherwise, if
<i>memkind_free(kind, ptr)</i> was already called before,
undefined behavior occurs. If <i>ptr</i> is <i>NULL</i>, no
operation is performed. In cases where the kind is unknown
in the context of the call to <b>memkind_free</b>()
<i>NULL</i>, can be given as the <i>kind</i> specified to
<b>memkind_free</b>(), but this will require a internal look
up for correct kind. <b>Note:</b> The look up for
<i>kind</i> could result in serious performance penalty,
which can be avoided by specifying a correct
<i>kind</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
CONFIGURATION MANAGEMENT:</b> <br>
The functions described in this section define a way to
create, delete and update kind specific configuration.
Except of <b>memkind_config_new</b>(), user must specify the
memkind configuration with the first argument to each
function. API described here is most useful with file-backed
kind of memory, e.g.
<b>memkind_create_pmem_with_config</b>() method.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_config_new</b>()
creates the memkind configuration.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_config_delete</b>()
deletes previously created memkind configuration, which must
have been returned by a previous call to
<b>memkind_config_new</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_config_set_path</b>()
updates the memkind <i>pmem_dir</i> configuration parameter,
which specifies directory path, where file-backed kind of
memory will be created. <b>Note:</b> This function does not
validate that <i>pmem_dir</i> specifies a valid path.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_config_set_size</b>()
updates the memkind <i>pmem_size</i> configuration
parameter, which allows to limit the file-backed kind memory
partition. <b>Note:</b> This function does not validate that
<i>pmem_size</i> is in valid range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_config_set_memory_usage_policy</b>()
updates the memkind <i>policy</i> configuration parameter,
which allows to tune up memory utilization. The user should
set the value based on the characteristics of application
that is using the library (e.g. prioritize memory usage, CPU
utilization), for more details about <i>policy</i> see the
<b>MEMORY USAGE POLICY</b> section below. <b>Note:</b> This
function does not validate that <i>policy</i> is in valid
range.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
MANAGEMENT:</b> <br>
There are built-in kinds that are always available and these
are enumerated in the <b>KINDS</b> section. The user can
also create their own kinds of memory. This section
describes the API&rsquo;s that enable the tracking of the
different kinds of memory and determining their
properties.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_create_pmem</b>()
is a convenient function used to create a file-backed kind
of memory. It allocates a temporary file in the given
directory <i>dir</i>. The file is created in a fashion
similar to <b>tmpfile</b>(3), so that the file name does not
appear when the directory is listed and the space is
automatically freed when the program terminates. The file is
truncated to a size of <i>max_size</i> bytes and the
resulting space is memory-mapped. <br>
Note that the actual file system space is not allocated
immediately, but only on a call to
<b>memkind_pmem_mmap</b>() (see <b>memkind_pmem</b>(3)).
This allows to create a pmem memkind of a pretty large size
without the need to reserve in advance the corresponding
file system space for the entire heap. If the value of
<i>max_size</i> equals 0, pmem memkind is only limited by
the capacity of the file system mounted under <i>dir</i>
argument. The minimum <i>max_size</i> value which allows to
limit the size of kind by the library is defined as
<b>MEMKIND_PMEM_MIN_SIZE</b>. Calling
<b>memkind_create_pmem</b>() with a size smaller than that
and different than 0 will return an error. The maximum
allowed size is not limited by <b>memkind</b>, but by the
file system specified by the <i>dir</i> argument. The
<i>max_size</i> passed in is the raw size of the memory pool
and <b>jemalloc</b> will use some of that space for its own
metadata. Returns zero if the pmem memkind is created
successfully or an error code from the <b>ERRORS</b> section
if not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_create_pmem_with_config</b>()
is a second function used to create a file-backed kind of
memory. Function behaves simillar to
<b>memkind_create_pmem</b>() but instead of passing
<i>dir</i> and <i>max_size</i> arguments, it uses
<i>config</i> param to specify characteristics of created
file-backed kind of memory (see <b>KIND CONFIGURATION
MANAGEMENT</b> section).</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_create_kind</b>()
creates kind that allocates memory with specific memory
type, memory binding policy and flags (see <b>MEMORY
FLAGS</b> section). The <i>memtype_flags</i> (see <b>MEMORY
TYPES</b> section) determine memory types to allocate,
<i>policy</i> argument is policy for specifying page binding
to memory types selected by <i>memtype_flags</i>. Returns
zero if the specified kind is created successfully or an
error code from the <b>ERRORS</b> section if not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_destroy_kind</b>()
destroys previously created kind object, which must have
been returned by a previous call to
<b>memkind_create_pmem</b>(),
<b>memkind_create_pmem_with_config</b>() or
<b>memkind_create_kind</b>(). Otherwise, or if
<i>memkind_destroy_kind(kind)</i> was already called before,
undefined behavior occurs. Note that, when the kind was
returned by <b>memkind_create_kind</b>() all allocated
memory must be freed before kind is destroyed, otherwise
this will cause memory leak. When the kind was returned by
<b>memkind_create_pmem</b>() or
<b>memkind_create_pmem_with_config</b>() all allocated
memory will be freed after kind will be destroyed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_check_available</b>()
returns zero if the specified <i>kind</i> is available or an
error code from the <b>ERRORS</b> section if it is not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>MEMKIND_PMEM_MIN_SIZE</b>
The minimum size which allows to limit the file-backed
memory partition.</p>


<p style="margin-left:11%; margin-top: 1em"><b>STATISTICS:</b>
<br>
The functions described in this section define a way to get
specific memory allocation statistics.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_update_cached_stats</b>()
is used to force an update of cached dynamic allocator
statistics. Statistics are not updated real-time by memkind
library and this method allows to force its update.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_get_stat</b>()
retrieves statistic of the specified type and returns it in
<i>value</i>. For more details about <i>stat</i> see the
<b>MEMORY STATISTICS TYPE</b> section below. Measured
statistic applies to specific <i>kind</i>, when <i>NULL</i>
is given as <i>kind</i> then statistic applies to memory
used by the whole memkind library. <b>Note:</b> You need to
call <b>memkind_update_cached_stats</b>() before calling
<b>memkind_get_stat</b>() because statistics are cached by
memkind library.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DECORATORS:</b>
<br>
The memkind library enables the user to define decorator
functions that can be called before and after each memkind
heap management API. The decorators that are called at the
beginning of the function end are named after that function
with <i>_pre</i> appended to the name and those that are
called at the end of the function are named after that
function with <i>_post</i> appended to the name. These are
weak symbols and if they are not present at link time they
are not called. The memkind library does not define these
symbols which are reserved for user definition. These
decorators can be used to track calls to the heap management
interface or to modify parameters. The decorators that are
called at the beginning of the allocator pass all inputs by
reference and the decorators that are called at the end of
the allocator pass the output by reference. This enables the
modification of the input and output of each heap management
function by the decorators.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LIBRARY
VERSION:</b> <br>
The memkind library version scheme consist major, minor and
patch numbers separated by dot. Combining those numbers, we
got the following representation: <br>
major.minor.patch, where:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-major number is incremented whenever API is changed
(loss of backward compatibility),</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-minor number is incremented whenever additional
extensions are introduced or behavior has been changed,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-patch number is incremented whenever small bug fixes
are added.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">memkind library
provide numeric representation of the version by exposing
the following API:</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_get_version</b>()
returns version number represented by a single integer
number, obtained from the formula: <br>
major * 1000000 + minor * 1000 + patch</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
major &lt; 1 means unstable API.</p>

<p style="margin-left:11%; margin-top: 1em">API standards:
<br>
-STANDARD API, API is considered as stable <br>
-NON-STANDARD API, API is considered as stable, however this
is not a standard way to use memkind <br>
-EXPERIMENTAL API, API is considered as unstable and the
subject to change</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_calloc</b>(),
<b>memkind_malloc</b>(), <b>memkind_realloc</b>() and
<b>memkind_defrag_reallocate</b>() returns the pointer to
the allocated memory or <i>NULL</i> if the request fails.
<b>memkind_malloc_usable_size</b>() returns the number of
usable bytes in the block of allocated memory pointed to by
<i>ptr</i>, a pointer to a block of memory allocated by
<b>memkind_malloc</b>() or a related function. If <i>ptr</i>
is <i>NULL</i>, 0 is returned. <b>memkind_free</b>() and
<b>memkind_error_message</b>() do not have return values.
All other memkind API&rsquo;s return 0 upon success and an
error code defined in the <b>ERRORS</b> section upon
failure. The memkind library avoids setting <i>errno</i>
directly, but calls to underlying libraries and system calls
may set <i>errno</i> (e.g.
<b>memkind_create_pmem</b>()).</p>

<h2>KINDS
<a name="KINDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The available
kinds of memory: <b><br>
MEMKIND_DEFAULT</b></p>

<p style="margin-left:22%;">Default allocation using
standard memory and default page size.</p>

<p style="margin-left:11%;"><b>MEMKIND_HUGETLB</b></p>

<p style="margin-left:22%;">Allocate from standard memory
using huge pages. <b>Note:</b> This kind requires huge pages
configuration described in <b>SYSTEM CONFIGURATION</b>
section.</p>

<p style="margin-left:11%;"><b>MEMKIND_GBTLB
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Allocate from standard memory
using 1GB chunks backed by huge pages. <b>Note:</b> This
kind requires huge pages configuration described in
<b>SYSTEM CONFIGURATION</b> section.</p>

<p style="margin-left:11%;"><b>MEMKIND_INTERLEAVE</b></p>

<p style="margin-left:22%;">Allocate pages interleaved
across all NUMA nodes with transparent huge pages
disabled.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW</b></p>

<p style="margin-left:22%;">Allocate from the closest high
bandwidth memory NUMA node at time of allocation. If there
is not enough high bandwidth memory to satisfy the request
<i>errno</i> is set to <b>ENOMEM</b> and the allocated
pointer is set to <i>NULL</i>.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_ALL</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except decision regarding closest NUMA node is postponed
until the time of first write.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_HUGETLB</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except the allocation is backed by huge pages. <b>Note:</b>
This kind requires huge pages configuration described in
<b>SYSTEM CONFIGURATION</b> section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_ALL_HUGETLB</b></p>

<p style="margin-left:22%;">Combination of
<b>MEMKIND_HBW_ALL</b> and <b>MEMKIND_HBW_HUGETLB</b>
properties. <b>Note:</b> This kind requires huge pages
configuration described in <b>SYSTEM CONFIGURATION</b>
section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except that if there is not enough high bandwidth memory to
satisfy the request, the allocation will fall back on
standard memory.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED_HUGETLB</b></p>

<p style="margin-left:22%;">Same as
<b>MEMKIND_HBW_PREFERRED</b> except the allocation is backed
by huge pages. <b>Note:</b> This kind requires huge pages
configuration described in <b>SYSTEM CONFIGURATION</b>
section.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_GBTLB
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except the allocation is backed by 1GB chunks of huge pages.
Note that <i>size</i> can take on any value, but full
gigabyte pages will allocated for each request, so remainder
of the last page will be wasted. This kind requires huge
pages configuration described in <b>SYSTEM CONFIGURATION</b>
section.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED_GBTLB
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Same as
<b>MEMKIND_HBW_GBTLB</b> except that if there is not enough
high bandwidth memory to satisfy the request, the allocation
will fall back on standard memory. <b>Note:</b> This kind
requires huge pages configuration described in <b>SYSTEM
CONFIGURATION</b> section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_INTERLEAVE</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except that the pages that support the allocation are
interleaved across all high bandwidth nodes and transparent
huge pages are disabled.</p>

<p style="margin-left:11%;"><b>MEMKIND_DAX_KMEM</b></p>

<p style="margin-left:22%;">Allocate from the closest
persistent memory NUMA node at time of allocation. If there
is not enough memory in the closest persistent memory NUMA
node to satisfy the request <i>errno</i> is set to
<b>ENOMEM</b> and the allocated pointer is set to
<i>NULL</i>.</p>


<p style="margin-left:11%;"><b>MEMKIND_DAX_KMEM_ALL</b></p>

<p style="margin-left:22%;">Allocate from the closest
persistent memory NUMA node available at the time of
allocation. If there is not enough memory on any of
persistent memory NUMA nodes to satisfy the request
<i>errno</i> is set to <b>ENOMEM</b> and the allocated
pointer is set to <i>NULL</i>.</p>


<p style="margin-left:11%;"><b>MEMKIND_DAX_KMEM_PREFERRED</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_DAX_KMEM</b>
except that if there is not enough memory in the closest
persistent memory NUMA node to satisfy the request, the
allocation will fall back on other memory NUMA nodes.
<b>Note:</b> For this kind, the allocation will not succeed
if two or more persistent memory NUMA nodes are in the same
shortest distance to the same CPU on which process is
eligible to run. Check on that eligibility is done upon
starting the application.</p>

<p style="margin-left:11%;"><b>MEMKIND_REGULAR</b></p>

<p style="margin-left:22%;">Allocate from regular memory
using the default page size. Regular means general purpose
memory from the NUMA nodes containing CPUs.</p>

<h2>MEMORY TYPES
<a name="MEMORY TYPES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The available
types of memory: <b><br>
MEMKIND_MEMTYPE_DEFAULT</b></p>

<p style="margin-left:22%;">Standard memory, the same as
process uses.</p>


<p style="margin-left:11%;"><b>MEMKIND_MEMTYPE_HIGH_BANDWIDTH</b></p>

<p style="margin-left:22%;">High bandwidth memory (HBM).
There must be at least two memory types with different
bandwidth to determine which is the HBM.</p>

<h2>MEMORY BINDING POLICY
<a name="MEMORY BINDING POLICY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The available
types of memory binding policy: <b><br>
MEMKIND_POLICY_BIND_LOCAL</b></p>

<p style="margin-left:22%;">Allocate local memory. If there
is not enough memory to satisfy the request <i>errno</i> is
set to <b>ENOMEM</b> and the allocated pointer is set to
<i>NULL</i>.</p>


<p style="margin-left:11%;"><b>MEMKIND_POLICY_BIND_ALL</b></p>

<p style="margin-left:22%;">Memory locality is ignored. If
there is not enough memory to satisfy the request
<i>errno</i> is set to <b>ENOMEM</b> and the allocated
pointer is set to <i>NULL</i>.</p>


<p style="margin-left:11%;"><b>MEMKIND_POLICY_PREFERRED_LOCAL</b></p>

<p style="margin-left:22%;">Allocate preferred memory that
is local. If there is not enough preferred memory to satisfy
the request or preferred memory is not available, the
allocation will fall back on any other memory.</p>


<p style="margin-left:11%;"><b>MEMKIND_POLICY_INTERLEAVE_LOCAL</b></p>

<p style="margin-left:22%;">Interleave allocation across
local memory. For n memory types the allocation will be
interleaved across all of them.</p>


<p style="margin-left:11%;"><b>MEMKIND_POLICY_INTERLEAVE_ALL</b></p>

<p style="margin-left:22%;">Interleave allocation. Locality
is ignored. For n memory types the allocation will be
interleaved across all of them.</p>


<p style="margin-left:11%;"><b>MEMKIND_POLICY_MAX_VALUE</b></p>

<p style="margin-left:22%;">Max policy value.</p>

<h2>MEMORY FLAGS
<a name="MEMORY FLAGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The available
types of memory flags: <b><br>
MEMKIND_MASK_PAGE_SIZE_2MB</b></p>

<p style="margin-left:22%;">Allocation backed by 2MB page
size.</p>

<h2>MEMORY USAGE POLICY
<a name="MEMORY USAGE POLICY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The available
types of memory usage policy: <b><br>
MEMKIND_MEM_USAGE_POLICY_DEFAULT</b></p>

<p style="margin-left:22%;">Default memory usage
policy.</p>


<p style="margin-left:11%;"><b>MEMKIND_MEM_USAGE_POLICY_CONSERVATIVE</b></p>

<p style="margin-left:22%;">Conservative memory usage
policy - prioritize memory usage at cost of performance.
<b>Note:</b> Memory usage policies have no effect for TBB
heap manager described in <b>ENVIRONMENT</b> section.</p>

<h2>MEMORY STATISTICS TYPE
<a name="MEMORY STATISTICS TYPE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The available
types of memory statistics: <b><br>
MEMKIND_STAT_TYPE_RESIDENT</b></p>

<p style="margin-left:22%;">Maximum number of bytes in
physically resident data pages mapped.</p>


<p style="margin-left:11%;"><b>MEMKIND_STAT_TYPE_ACTIVE</b></p>

<p style="margin-left:22%;">Total number of bytes in active
pages.</p>


<p style="margin-left:11%;"><b>MEMKIND_STAT_TYPE_ALLOCATED</b></p>

<p style="margin-left:22%;">Total number of allocated
bytes.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_posix_memalign</b>()</p>

<p style="margin-left:22%;">returns the one of the POSIX
standard error codes <b>EINVAL</b> or <b>ENOMEM</b> as
defined in <i>&lt;errno.h&gt;</i> if an error occurs (these
have positive values). If the <i>alignment</i> parameter is
not a power of two or is not a multiple of
<i>sizeof(void*)</i>, then <b>EINVAL</b> is returned. If
there is insufficient memory to satisfy the request then
<b>ENOMEM</b> is returned.</p>

<p style="margin-left:11%; margin-top: 1em">All functions
other than <b>memkind_posix_memalign</b>() which have an
integer return type return one of the negative error codes
as defined in <i>&lt;memkind.h&gt;</i> and described below.
<b><br>
MEMKIND_ERROR_UNAVAILABLE</b></p>

<p style="margin-left:22%;">Requested memory kind is not
available</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_MBIND</b></p>

<p style="margin-left:22%;">Call to <b>mbind</b>(2)
failed</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_MMAP</b></p>

<p style="margin-left:22%;">Call to <b>mmap</b>(2)
failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_MALLOC</b></p>

<p style="margin-left:22%;">Call to jemalloc&rsquo;s
<b>malloc</b>() failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_ENVIRON</b></p>

<p style="margin-left:22%;">Error parsing environment
variable <i>MEMKIND_*</i></p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_INVALID</b></p>

<p style="margin-left:22%;">Invalid input arguments to
memkind routine</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_TOOMANY</b></p>

<p style="margin-left:22%;">Error trying to initialize more
than maximum <b>MEMKIND_MAX_KIND</b> number of kinds</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_BADOPS</b></p>

<p style="margin-left:22%;">Error memkind operation
structure is missing or invalid</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_HUGETLB</b></p>

<p style="margin-left:22%;">Unable to allocate huge
pages</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_MEMTYPE_NOT_AVAILABLE</b></p>

<p style="margin-left:22%;">Error requested memory type is
not available</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_OPERATION_FAILED</b></p>

<p style="margin-left:22%;">Error memkind operation
failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_ARENAS_CREATE</b></p>

<p style="margin-left:22%;">Call to jemalloc&rsquo;s
<b>arenas.create</b>() failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_RUNTIME</b></p>

<p style="margin-left:22%;">Unspecified run-time error</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/usr/bin/memkind-hbw-nodes</i></p>

<p style="margin-left:22%;">Prints a comma-separated list
of high bandwidth nodes.</p>


<p style="margin-left:11%;"><i>/usr/bin/memkind-auto-dax-kmem-nodes</i></p>

<p style="margin-left:22%;">Prints a comma-separated list
of persistent memory NUMA nodes, which are automatically
detected.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MEMKIND_HBW_NODES</b></p>

<p style="margin-left:22%;">This environment variable is a
comma-separated list of NUMA nodes that are treated as high
bandwidth. Uses the <i>libnuma</i> routine
<b>numa_parse_nodestring</b>() for parsing, so the syntax
described in the <b>numa</b>(3) man page for this routine
applies: e.g. 1-3,5 is a valid setting.</p>


<p style="margin-left:11%;"><b>MEMKIND_DAX_KMEM_NODES</b></p>

<p style="margin-left:22%;">This environment variable is a
comma-separated list of NUMA nodes that are treated as PMEM
memory. Uses the <i>libnuma</i> routine
<b>numa_parse_nodestring</b>() for parsing, so the syntax
described in the <b>numa</b>(3) man page for this routine
applies: e.g. 1-3,5 is a valid setting.</p>


<p style="margin-left:11%;"><b>MEMKIND_ARENA_NUM_PER_KIND</b></p>

<p style="margin-left:22%;">This environment variable
allows leveraging internal mechanism of the library for
setting number of arenas per kind. Value should be a
positive integer (not greater than <b>INT_MAX</b> defined in
<i>&lt;limits.h&gt;</i>). The user should set the value
based on the characteristics of application that is using
the library. Higher value can provide better performance in
extremely multithreaded applications at the cost of memory
overhead. See section <b>IMPLEMENTATION NOTES</b> of
<b>jemalloc</b>(3) for more details about arenas.</p>

<p style="margin-left:11%;"><b>MEMKIND_HOG_MEMORY</b></p>

<p style="margin-left:22%;">Controls behavior of memkind
with regards to returning memory to underlying OS. Setting
<b>MEMKIND_HOG_MEMORY</b> to 1 causes memkind to not release
memory to OS in anticipation of memory reuse soon. This will
improve latency of &rsquo;free&rsquo; operations but
increase memory usage.</p>

<p style="margin-left:11%;"><b>MEMKIND_DEBUG</b></p>

<p style="margin-left:22%;">Controls logging mechanism in
memkind. Setting <b>MEMKIND_DEBUG</b> to 1 enables printing
messages like errors and general information about
environment to <i>stderr</i>.</p>


<p style="margin-left:11%;"><b>MEMKIND_BACKGROUND_THREAD_LIMIT</b></p>

<p style="margin-left:22%;">Enable background worker
threads. Value should be from range 0 to maximum number of
cpus. Setting <b>MEMKIND_BACKGROUND_THREAD_LIMIT</b> to
specific value will limit maximum number of background
worker threads to this value. 0 means maximum number of
background worker threads will be limited to maximum number
of cpus.</p>


<p style="margin-left:11%;"><b>MEMKIND_HEAP_MANAGER</b></p>

<p style="margin-left:22%;">Controls heap management
behavior in memkind library by switching to one of the
available heap managers. <br>
Values: <br>
JEMALLOC - sets the jemalloc heap manager <br>
TBB - sets the Intel Threading Building Blocks heap manager.
This option requires installed <br>
Intel Threading Building Blocks library.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>MEMKIND_HEAP_MANAGER</b> is not set then the jemalloc
heap manager will be used by default.</p>

<h2>SYSTEM CONFIGURATION
<a name="SYSTEM CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining 2MB (HUGETLB) need allocated huge pages in the
kernel&rsquo;s huge page pool. <b><br>
HUGETLB (huge pages)</b></p>

<p style="margin-left:22%;">Current number of
&quot;persistent&quot; huge pages can be read from
<i>/proc/sys/vm/nr_hugepages</i> file. Proposed way of
setting hugepages is: <b>sudo sysctl
vm.nr_hugepages=&lt;number_of_hugepages&gt;</b>. More
information can be found here:
<a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</a></p>

<h2>STATIC LINKING
<a name="STATIC LINKING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When linking
statically against memkind, <i>libmemkind.a</i> should be
used together with its dependencies <i>libnuma</i> and
pthread. Pthread can be linked by adding
<i>/usr/lib64/libpthread.a</i> as a dependency (exact path
may vary). Typically <i>libnuma</i> will need to be compiled
from sources to use it as a static dependency.
<i>libnuma</i> can be reached on GitHub:
<a href="https://github.com/numactl/numactl">https://github.com/numactl/numactl</a></p>

<h2>KNOWN ISSUES
<a name="KNOWN ISSUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>HUGETLB
(huge pages)</b></p>

<p style="margin-left:22%;">There might be some overhead in
huge pages consumption caused by heap management. If your
allocation fails because of OOM, please try to allocate
extra huge pages (e.g. 8 huge pages).</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2014 - 2019 Intel Corporation. All rights reserved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>malloc</b>(3),
<b>malloc_usable_size</b>(3), <b>numa</b>(3),
<b>numactl</b>(8), <b>mbind</b>(2), <b>mmap</b>(2),
<b>move_pages</b>(2), <b>jemalloc</b>(3),
<b>memkind_dax_kmem</b>(3), <b>memkind_default</b>(3),
<b>memkind_arena</b>(3), <b>memkind_hbw</b>(3),
<b>memkind_hugetlb</b>(3), <b>memkind_pmem</b>(3)</p>
<hr>
</body>
</html>
