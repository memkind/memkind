<!-- Creator     : groff version 1.20 -->
<!-- CreationDate: Tue Dec 11 23:51:42 2018 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HBWMALLOC</title>

</head>
<body>

<h1 align="center">HBWMALLOC</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#SYSTEM CONFIGURATION">SYSTEM CONFIGURATION</a><br>
<a href="#KNOWN ISSUES">KNOWN ISSUES</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">hbwmalloc
&minus; The high bandwidth memory interface <br>
Note: hbwmalloc.h functionality is considered as stable API
(STANDARD API).</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;hbwmalloc.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Link with
-lmemkind</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hbw_check_available(void); <br>
void* hbw_malloc(size_t</b> <i>size</i><b>); <br>
void* hbw_calloc(size_t</b> <i>nmemb</i><b>, size_t</b>
<i>size</i><b>); <br>
void* hbw_realloc (void</b> <i>*ptr</i><b>, size_t</b>
<i>size</i><b>); <br>
void hbw_free(void</b> <i>*ptr</i><b>); <br>
int hbw_posix_memalign(void</b> <i>**memptr</i><b>,
size_t</b> <i>alignment</i><b>, size_t</b> <i>size</i><b>);
<br>
int hbw_posix_memalign_psize(void</b> <i>**memptr</i><b>,
size_t</b> <i>alignment</i><b>, size_t</b> <i>size</i><b>,
hbw_pagesize_t</b> <i>pagesize</i><b>); <br>
hbw_policy_t hbw_get_policy(void); <br>
int hbw_set_policy(hbw_policy_t</b> <i>mode</i><b>); <br>
int hbw_verify_memory_region(void</b> <i>*addr</i><b>,
size_t</b> <i>size</i><b>, int</b> <i>flags</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>hbw_check_available</b>()
returns zero if high bandwidth memory is available or an
error code described in the <b>ERRORS</b> section if
not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_malloc</b>()
allocates <i>size</i> bytes of uninitialized high bandwidth
memory. The allocated space is suitably aligned (after
possible pointer coercion) for storage of any type of
object. If <i>size</i> is zero then <b>hbw_malloc</b>()
returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_calloc</b>()
allocates space for <i>nmemb</i> objects in high bandwidth
memory, each <i>size</i> bytes in length. The result is
identical to calling <b>hbw_malloc</b>() with an argument of
<i>nmemb</i>*<i>size</i> , with the exception that the
allocated memory is explicitly initialized to zero bytes. If
<i>nmemb</i> or <i>size</i> is 0, then <b>hbw_calloc</b>()
returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_realloc</b>()
changes the size of the previously allocated high bandwidth
memory referenced by <i>ptr</i> to <i>size</i> bytes. The
contents of the memory are unchanged up to the lesser of the
new and old sizes. If the new size is larger, the contents
of the newly allocated portion of the memory are undefined.
Upon success, the memory referenced by <i>ptr</i> is freed
and a pointer to the newly allocated high bandwidth memory
is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
hbw_realloc</b>() may move the memory allocation, resulting
in a different return value than <i>ptr</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>ptr</i>
is NULL, the <b>hbw_realloc</b>() function behaves
identically to <b>hbw_malloc</b>() for the specified size.
The address <i>ptr</i>, if not NULL, was returned by a
previous call to <b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
<b>hbw_realloc</b>(), or <b>hbw_posix_memalign</b>().
Otherwise, or if <i>hbw_free(ptr)</i> was called before,
undefined behavior occurs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
hbw_realloc</b>() cannot be used with a pointer returned by
<b>hbw_posix_memalign_psize</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_free</b>()
causes the allocated memory referenced by <i>ptr</i> to be
made available for future allocations. If <i>ptr</i> is
NULL, no action occurs. The address <i>ptr</i>, if not NULL,
must have been returned by a previous call to
<b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
<b>hbw_realloc</b>(), <b>hbw_posix_memalign</b>(), or
<b>hbw_posix_memalign_psize</b>(). Otherwise, if
<i>hbw_free(ptr)</i> was called before, undefined behavior
occurs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_posix_memalign</b>()
allocates <i>size</i> bytes of high bandwidth memory such
that the allocation&rsquo;s base address is an even multiple
of <i>alignment</i>, and returns the allocation in the value
pointed to by <i>memptr</i>. The requested <i>alignment</i>
must be a power of 2 at least as large as <i>sizeof(void
*)</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_posix_memalign_psize</b>()
allocates <i>size</i> bytes of high bandwidth memory such
that the allocation&rsquo;s base address is an even multiple
of <i>alignment</i>, and returns the allocation in the value
pointed to by <i>memptr</i>. The requested <i>alignment</i>
must be a power of 2 at least as large as <i>sizeof(void
*)</i>. The memory will be allocated using pages determined
by the <i>pagesize</i> variable which may be one of the
following enumerated values: <b><br>
HBW_PAGESIZE_4KB</b></p>

<p style="margin-left:22%;">The four kilobyte page size
option. Note that with transparent huge pages enabled these
allocations may be promoted by the operating system to two
megabyte pages.</p>

<p style="margin-left:11%;"><b>HBW_PAGESIZE_2MB</b></p>

<p style="margin-left:22%;">The two megabyte page size
option. Note: This page size requires huge pages
configuration described in SYSTEM CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>HBW_PAGESIZE_1GB
(DEPRECATED)</b></p>

<p style="margin-left:22%;">This option allows the user to
specify arbitrary sizes backed by 1GB chunks of huge pages.
Huge pages are allocated even if the size is not a modulo of
1GB. Note: This page size requires huge pages configuration
described in SYSTEM CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>HBW_PAGESIZE_1GB_STRICT
(DEPRECATED)</b></p>

<p style="margin-left:22%;">The total size of the
allocation must be a multiple of 1GB with this option,
otherwise the allocation will fail. Note: This page size
requires huge pages configuration described in SYSTEM
CONFIGURATION section.</p>

<p style="margin-left:11%;">HBW_PAGESIZE_2MB,
HBW_PAGESIZE_1GB and HBW_PAGESIZE_1GB_STRICT options <br>
are not supported with HBW_POLICY_INTERLEAVE policy.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_get_policy</b>()
returns the current fallback policy when insufficient high
bandwidth memory is available.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_set_policy</b>()
sets the current fallback policy. The policy can be modified
only once in the lifetime of an application and before
calling hbw_*alloc() or hbw_posix_memalign*() function. <br>
Note: If the policy is not set, than HBW_POLICY_PREFERRED
will be used by default. <b><br>
HBW_POLICY_BIND</b></p>

<p style="margin-left:22%;">If insufficient high bandwidth
memory from the nearest NUMA node is available to satisfy a
request, the allocated pointer is set to NULL and
<i>errno</i> is set to ENOMEM. If insufficient high
bandwidth memory pages are available at fault time the Out
Of Memory (OOM) killer is triggered. Note that pages are
faulted exclusively from the high bandwidth NUMA node
nearest at time of allocation, not at time of fault.</p>

<p style="margin-left:11%;"><b>HBW_POLICY_BIND_ALL</b></p>

<p style="margin-left:22%;">If insufficient high bandwidth
memory is available to satisfy a request, the allocated
pointer is set to NULL and <i>errno</i> is set to ENOMEM. If
insufficient high bandwidth memory pages are available at
fault time the Out Of Memory (OOM) killer is triggered. Note
that pages are faulted from the high bandwidth NUMA nodes.
Nearest NUMA node is selected at time of page fault.</p>


<p style="margin-left:11%;"><b>HBW_POLICY_PREFERRED</b></p>

<p style="margin-left:22%;">If insufficient memory is
available from the high bandwidth NUMA node closest at
allocation time, fall back to standard memory (default) with
the smallest NUMA distance.</p>


<p style="margin-left:11%;"><b>HBW_POLICY_INTERLEAVE</b></p>

<p style="margin-left:22%;">Interleave faulted pages from
across all high bandwidth NUMA nodes using standard size
pages (the Transparent Huge Page feature is disabled).</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_verify_memory_region</b>()
verifies if memory region fully fall into high bandwidth
memory. Returns 0 if memory address range from <i>addr</i>
to <i>addr</i> + <i>size</i> is allocated in high bandwidth
memory, -1 if any fragment of memory was not backed by high
bandwidth memory [e.g. when memory is not initialized] or
one of error codes described in ERRORS section.</p>

<p style="margin-left:11%; margin-top: 1em">Using this
function in production code may result in serious
performance penalty.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Flags</i>
argument may include optional flags that modifies function
behaviour: <b><br>
HBW_TOUCH_PAGES</b></p>

<p style="margin-left:22%;">Before checking pages, function
will touch first byte of all pages in address range starting
from <i>addr</i> to <i>addr</i> + <i>size</i> by read and
write (so the content will be overwritten by the same data
as it was read). Using this option may trigger Out Of Memory
killer.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>hbw_get_policy</b>()
returns <b>HBW_POLICY_BIND, HBW_POLICY_BIND_ALL,
HBW_POLICY_PREFERRED</b> or <b>HBW_POLICY_INTERLEAVE</b>
which represents the current high bandwidth policy.
<b>hbw_free</b>() do not have return value.
<b>hbw_malloc</b>() <b>hbw_calloc</b>(), and
<b>hbw_realloc</b>() return the pointer to the allocated
memory, or NULL if the request fails.
<b>hbw_posix_memalign</b>(),
<b>hbw_posix_memalign_psize</b>() and
<b>hbw_set_policy</b>() return zero on success and return an
error code as described in the <b>ERRORS</b> section below
on failure.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Error codes
described here are the POSIX standard error codes as <br>
defined in &lt;errno.h&gt; <b><br>
hbw_check_available</b>()</p>

<p style="margin-left:22%;">returns <b>ENODEV</b> if
high-bandwidth memory is unavailable.</p>

<p style="margin-left:11%;"><b>hbw_posix_memalign</b>() and
<b>hbw_posix_memalign_psize</b>()</p>

<p style="margin-left:22%;">If the <i>alignment</i>
parameter is not a power of two, or was not a multiple of
<i>sizoeof(void *)</i>, then <b>EINVAL</b> is returned. If
the policy and <i>pagesize</i> combination is unsupported
then <b>EINVAL</b> is returned. If there was insufficient
memory to satisfy the request then <b>ENOMEM</b> is
returned.</p>

<p style="margin-left:11%;"><b>hbw_set_policy</b>()</p>

<p style="margin-left:22%;">returns <b>EPERM</b> if
hbw_set_policy () was called more than once, or <b>EINVAL
if</b> <i>mode</i> argument was neither
<b>HBW_POLICY_PREFERRED, HBW_POLICY_BIND,
HBW_POLICY_BIND_ALL</b> nor
<b>HBW_POLICY_INTERLEAVE.</b></p>


<p style="margin-left:11%;"><b>hbw_verify_memory_region</b>()</p>

<p style="margin-left:22%;">returns <b>EINVAL</b> if
<i>addr</i> is NULL, <i>size</i> equals 0 or <i>flags</i>
contained unsupported bit set. If memory pointed by
<i>addr</i> could not be verified then <b>EFAULT</b> is
returned.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>hbwmalloc.h</i> file defines the external functions and
enumerations for the hbwmalloc library. These interfaces
define a heap manager that targets high bandwidth memory
numa nodes.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/usr/bin/memkind-hbw-nodes</i></p>

<p style="margin-left:22%;">Prints a comma separated list
of high bandwidth nodes.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MEMKIND_HBW_NODES</b></p>

<p style="margin-left:22%;">This environment variable is a
comma separated list of NUMA nodes that are treated as high
bandwidth. Uses the <i>libnuma</i> routine
<b>numa_parse_nodestring</b>() for parsing, so the syntax
described in the <b>numa</b>(3) man page for this routine
applies for example: 1-3,5 is a valid setting.</p>


<p style="margin-left:11%;"><b>MEMKIND_ARENA_NUM_PER_KIND</b></p>

<p style="margin-left:22%;">This environment variable
allows leveraging internal mechanism of the library for
setting number of arenas per kind. Value should be a
positive integer (not greater than INT_MAX defined in
limits.h). The user should set the value based on the
characteristics of application that is using the library.
Higher value can provide better performance in extremely
multithreaded applications at the cost of memory overhead.
See section &quot;IMPLEMENTATION NOTES&quot; of
<b>jemalloc</b>(3) for more details about arenas.</p>


<p style="margin-left:11%;"><b>MEMKIND_HEAP_MANAGER</b></p>

<p style="margin-left:22%;">Controls heap management
behavior in memkind library by switching to one of the
available heap managers. <br>
Values: <br>
JEMALLOC &acirc; sets the jemalloc heap manager <br>
TBB &acirc; sets the Intel Threading Building Blocks heap
manager. This option requires installed <br>
Intel Threading Building Blocks library. If the
MEMKIND_HEAP_MANAGER is not set then the jemalloc heap
manager will be used by default.</p>

<h2>SYSTEM CONFIGURATION
<a name="SYSTEM CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining 2MB (HUGETLB) need allocated huge pages in the
kernel&rsquo;s huge page pool. <b><br>
HUGETLB (huge pages)</b></p>

<p style="margin-left:22%;">Current number of
&quot;persistent&quot; huge pages can be read from
/proc/sys/vm/nr_hugepages file. Proposed way of setting
hugepages is: &quot;sudo sysctl
vm.nr_hugepages=&lt;number_of_hugepages&gt;&quot;. More
information can be found here:
https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</p>

<h2>KNOWN ISSUES
<a name="KNOWN ISSUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>HUGETLB
(huge pages)</b></p>

<p style="margin-left:22%;">There might be some overhead in
huge pages consumption caused by heap management. If your
allocation fails because of OOM, please try to allocate
extra huge pages (e.g. 8 huge pages).</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2014 - 2018 Intel Corporation. All rights reserved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>malloc</b>(3),
<b>numa</b>(3), <b>numactl</b>(8), <b>mbind</b>(2),
<b>mmap</b>(2), <b>move_pages</b>(2) <b>jemalloc</b>(3)
<b>memkind</b>(3)</p>
<hr>
</body>
</html>
