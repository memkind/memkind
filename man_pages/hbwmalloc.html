<!-- Creator     : groff version 1.20 -->
<!-- CreationDate: Wed Dec  7 10:34:42 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HBWMALLOC</title>

</head>
<body>

<h1 align="center">HBWMALLOC</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#SYSTEM CONFIGURATION">SYSTEM CONFIGURATION</a><br>
<a href="#KNOWN ISSUES">KNOWN ISSUES</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">hbwmalloc
&minus; The high bandwidth memory interface <br>
Note: hbwmalloc.h functionality is considered as stable API
(STANDARD API).</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;hbwmalloc.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Link with
-lmemkind</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hbw_check_available(void); <br>
void* hbw_malloc(size_t</b> <i>size</i><b>); <br>
void* hbw_calloc(size_t</b> <i>nmemb</i><b>, size_t</b>
<i>size</i><b>); <br>
void* hbw_realloc (void</b> <i>*ptr</i><b>, size_t</b>
<i>size</i><b>); <br>
void hbw_free(void</b> <i>*ptr</i><b>); <br>
int hbw_posix_memalign(void</b> <i>**memptr</i><b>,
size_t</b> <i>alignment</i><b>, size_t</b> <i>size</i><b>);
<br>
int hbw_posix_memalign_psize(void</b> <i>**memptr</i><b>,
size_t</b> <i>alignment</i><b>, size_t</b> <i>size</i><b>,
hbw_pagesize_t</b> <i>pagesize</i><b>); <br>
hbw_policy_t hbw_get_policy(void); <br>
int hbw_set_policy(hbw_policy_t</b> <i>mode</i><b>); <br>
int hbw_verify_memory_region(void</b> <i>*addr</i><b>,
size_t</b> <i>size</i><b>, int</b> <i>flags</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>hbw_check_available</b>()
returns 0 if high bandwidth memory is available and an error
code described in the <b>ERRORS</b> section if not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_malloc</b>()
allocates <i>size</i> bytes of uninitialized high bandwidth
memory. The allocated space is suitably aligned (after
possible pointer coercion) for storage of any type of
object. If <i>size</i> is zero then <b>hbw_malloc</b>()
returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_calloc</b>()
allocates space for <i>nmemb</i> objects in high bandwidth
memory, each <i>size</i> bytes in length. The result is
identical to calling <b>hbw_malloc</b>() with an argument of
<i>nmemb</i>*<i>size</i> , with the exception that the
allocated memory is explicitly initialized to zero bytes. If
<i>nmemb</i> or <i>size</i> is 0, then <b>hbw_calloc</b>()
returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_realloc</b>()
changes the size of the previously allocated high bandwidth
memory referenced by <i>ptr</i> to <i>size</i> bytes. The
contents of the memory are unchanged up to the lesser of the
new and old sizes. If the new size is larger, the contents
of the newly allocated portion of the memory are undefined.
Upon success, the memory referenced by <i>ptr</i> is freed
and a pointer to the newly allocated high bandwidth memory
is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
hbw_realloc</b>() may move the memory allocation, resulting
in a different return value than <i>ptr</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>ptr</i>
is NULL, the <b>hbw_realloc</b>() function behaves
identically to <b>hbw_malloc</b>() for the specified size.
The address <i>ptr</i>, if not NULL, was returned by a
previous call to <b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
<b>hbw_realloc</b>(), or <b>hbw_posix_memalign</b>().
Otherwise, or if <i>hbw_free(ptr)</i> was called before,
undefined behavior occurs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
hbw_realloc</b>() cannot be used with a pointer returned by
<b>hbw_posix_memalign_psize</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_free</b>()
causes the allocated memory referenced by <i>ptr</i> to be
made available for future allocations. If <i>ptr</i> is
NULL, no action occurs. The address <i>ptr</i>, if not NULL,
must have been returned by a previous call to
<b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
<b>hbw_realloc</b>(), <b>hbw_posix_memalign</b>(), or
<b>hbw_posix_memalign_psize</b>(). Otherwise, if
<i>hbw_free(ptr)</i> was called before, undefined behavior
occurs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_posix_memalign</b>()
allocates <i>size</i> bytes of high bandwidth memory such
that the allocation&rsquo;s base address is an even multiple
of <i>alignment</i>, and returns the allocation in the value
pointed to by <i>memptr</i>. The requested <i>alignment</i>
must be a power of 2 at least as large as <i>sizeof(void
*)</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_posix_memalign_psize</b>()
allocates <i>size</i> bytes of high bandwidth memory such
that the allocation&rsquo;s base address is an even multiple
of <i>alignment</i>, and returns the allocation in the value
pointed to by <i>memptr</i>. The requested <i>alignment</i>
must be a power of 2 at least as large as <i>sizeof(void
*)</i>. The memory will be allocated using pages determined
by the <i>pagesize</i> variable which may be one of the
following enumerated values: <b><br>
HBW_PAGESIZE_4KB</b></p>

<p style="margin-left:22%;">The four kilobyte page size
option. Note that with transparent huge pages enabled these
allocations may be promoted by the operating system to two
megabyte pages.</p>

<p style="margin-left:11%;"><b>HBW_PAGESIZE_2MB</b></p>

<p style="margin-left:22%;">The two megabyte page size
option. Note: This page size requires huge pages
configuration described in SYSTEM CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>HBW_PAGESIZE_1GB</b></p>

<p style="margin-left:22%;">This option allows the user to
specify arbitrary sizes backed by one gigabytes pages.
Gigabyte pages are allocated even if the size is not a
modulo of 1GB. A good example of using this feature with
realloc is shown in gb_realloc_example.c. Note: This page
size requires gigabyte pages configuration described in
SYSTEM CONFIGURATION section.</p>


<p style="margin-left:11%;"><b>HBW_PAGESIZE_1GB_STRICT</b></p>

<p style="margin-left:22%;">The one gigabyte page size
option. The total size of the allocation must be a multiple
of 1GB with this option, otherwise the allocation will fail.
Note: This page size requires gigabyte pages configuration
described in SYSTEM CONFIGURATION section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_get_policy</b>()
returns the current fallback policy when insufficient high
bandwith memory is available.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_set_policy</b>()
sets the current fallback policy. The policy can be modified
only once in the lifetime of an application and before
calling hbw_*alloc() or hbw_posix_memalign*() function. <br>
Note: If the policy is not set, than HBW_POLICY_PREFERRED
will be used by default. <b><br>
HBW_POLICY_BIND</b></p>

<p style="margin-left:22%;">If insufficient high bandwidth
memory from the nearest NUMA node is available to satisfy a
request, the allocated pointer is set to NULL and
<i>errno</i> is set to ENOMEM. If insufficient high
bandwidth memory pages are available at fault time the Out
Of Memory (OOM) killer is triggered. Note that pages are
faulted exclusively from the high bandwidth NUMA node
nearest at time of allocation, not at time of fault.</p>


<p style="margin-left:11%;"><b>HBW_POLICY_PREFERRED</b></p>

<p style="margin-left:22%;">If insufficient memory is
available from the high bandwidth NUMA node closest at
allocation time, fall back to standard memory (default) with
the smallest NUMA distance.</p>


<p style="margin-left:11%;"><b>HBW_POLICY_INTERLEAVE</b></p>

<p style="margin-left:22%;">Interleave faulted pages from
across all high bandwidth NUMA nodes using standard size
pages (the Transparent Huge Page feature is disabled).</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_verify_memory_region</b>()
verifies if memory region fully fall into high bandwidth
memory. Returns: 0 if memory in address range from
<i>addr</i> to <i>addr</i> + <i>size</i> is allocated in
high bandwidth memory, -1 if any fragment of memory was not
backed by high bandwidth memory [e.g. when memory is not
initalized] or one of error codes described in ERRORS
section.</p>

<p style="margin-left:11%; margin-top: 1em">Using this
function in production code may result in serious
performance penalty.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Flags</i>
argument may include optional flags that modifies function
behaviour: <b><br>
HBW_TOUCH_PAGES</b></p>

<p style="margin-left:22%;">Before checking pages, function
will touch first byte of all pages in address range starting
from <i>addr</i> to <i>addr</i> + <i>size</i> by read and
write (so the content will be overwitten by the same data as
it was read). Using this option may trigger Out Of Memory
killer.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>hbw_get_policy</b>()
returns <b>HBW_POLICY_BIND</b> or
<b>HBW_POLICY_PREFERRED</b> which represents the current
high bandwidth policy. <b>hbw_free</b>() do not have return
value. <b>hbw_malloc</b>() <b>hbw_calloc</b>(), and
<b>hbw_realloc</b>() return the pointer to the allocated
memory, or NULL if the request fails.
<b>hbw_posix_memalign</b>(),
<b>hbw_posix_memalign_psize</b>() and
<b>hbw_set_policy</b>() return zero on success and return an
error code as described in the <b>ERRORS</b> section below
on failure.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Error codes
described here are the POSIX standard error codes as <br>
defined in &lt;errno.h&gt; <b><br>
hbw_check_available</b>()</p>

<p style="margin-left:22%;">returns <b>ENODEV</b> if
high-bandwidth memory is unavailable.</p>

<p style="margin-left:11%;"><b>hbw_posix_memalign</b>() and
<b>hbw_posix_memalign_psize</b>()</p>

<p style="margin-left:22%;">If the <i>alignment</i>
parameter is not a power of two, or was not a multiple of
<i>sizoeof(void *)</i>, then <b>EINVAL</b> is returned. If
there was insufficient memory to satisfy the request then
<b>ENOMEM</b> is returned.</p>

<p style="margin-left:11%;"><b>hbw_set_policy</b>()</p>

<p style="margin-left:22%;">returns <b>EPERM</b> if
hbw_set_policy () was called more than once, or <b>EINVAL
if</b> <i>mode</i> argument was neither
<b>HBW_POLICY_PREFERRED, HBW_POLICY_BIND</b> nor
<b>HBW_POLICY_INTERLEAVE.</b></p>


<p style="margin-left:11%;"><b>hbw_verify_memory_region</b>()</p>

<p style="margin-left:22%;">returns <b>EINVAL</b> if
<i>addr</i> is NULL, <i>size</i> equals 0 or <i>flags</i>
contained unsupported bit set. If memory pointed by
<i>addr</i> could not be verified then <b>EFAULT</b> is
returned.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>hbwmalloc.h</i> file defines the external functions and
enumerations for the hbwmalloc library. These interfaces
define a heap manager that targets high bandwidth memory
numa nodes.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/usr/bin/memkind-hbw-nodes</i></p>

<p style="margin-left:22%;">Prints a comma separated list
of high bandwidth nodes.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MEMKIND_HBW_NODES</b></p>

<p style="margin-left:22%;">This environment variable is a
comma separated list of NUMA nodes that are treated as high
bandwidth. Uses the <i>libnuma</i> routine
<b>numa_parse_nodestring</b>() for parsing, so the syntax
described in the <b>numa</b>(3) man page for this routine
applies for example: 1-3,5 is a valid setting.</p>


<p style="margin-left:11%;"><b>MEMKIND_ARENA_NUM_PER_KIND</b></p>

<p style="margin-left:22%;">This environment variable
allows leveraging internal mechanism of the library for
setting number of arenas per kind. Value should be a
positive integer (not greater than INT_MAX defined in
limits.h). The user should set the value based on the
characteristics of application that is using the library.
Higher value can provide better performance in extremely
multithreaded applications at the cost of memory overhead.
See section &quot;IMPLEMENTATION NOTES&quot; of
<b>jemalloc</b>(3) for more details about arenas.</p>

<h2>SYSTEM CONFIGURATION
<a name="SYSTEM CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining 2MB and 1GB pages (HUGETLB and GBTLB) need
allocated huge pages in the kernel&rsquo;s huge page pool.
<b><br>
HUGETLB (huge pages)</b></p>

<p style="margin-left:22%;">Current number of
&quot;persistent&quot; huge pages can be read from
/proc/sys/vm/nr_hugepages file. Proposed way of setting
hugepages is: &quot;sudo sysctl
vm.nr_hugepages=&lt;number_of_hugepages&gt;&quot;. More
informations can be found here:
https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</p>

<p style="margin-left:11%;"><b>GBTLB (gigabyte
pages)</b></p>

<p style="margin-left:22%;">Number of preallocated gigabyte
pages can be read from /proc/cmdline (hugepagesz=1G
nr_hugepages=N). Setting gigabyte hugepages is available by
kernel commandline. From 3.16 and later kernels, users can
allocate gigabyte pages like its done for 2MB pages.</p>

<h2>KNOWN ISSUES
<a name="KNOWN ISSUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>HUGETLB
(huge pages)</b></p>

<p style="margin-left:22%;">There might be some overhead in
huge pages consumption caused by heap management. If your
allocation fails because of OOM, please try to allocate
extra huge pages (e.g. 8 huge pages).</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2014 - 2016 Intel Corporation. All rights reserved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>malloc</b>(3),
<b>numa</b>(3), <b>numactl</b>(8), <b>mbind</b>(2),
<b>mmap</b>(2), <b>move_pages</b>(2) <b>jemalloc</b>(3)
<b>memkind</b>(3)</p>
<hr>
</body>
</html>
