<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Wed Sep 16 10:45:04 2020 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HBWMALLOC</title>

</head>
<body>

<h1 align="center">HBWMALLOC</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#SYSTEM CONFIGURATION">SYSTEM CONFIGURATION</a><br>
<a href="#KNOWN ISSUES">KNOWN ISSUES</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">hbwmalloc - The
high bandwidth memory interface <b><br>
Note:</b> <i>hbwmalloc.h</i> functionality is considered as
stable API (STANDARD API).</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;hbwmalloc.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Link with
-lmemkind</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hbw_check_available(void); <br>
void* hbw_malloc(size_t</b> <i>size</i><b>); <br>
void* hbw_calloc(size_t</b> <i>nmemb</i><b>, size_t</b>
<i>size</i><b>); <br>
void* hbw_realloc (void</b> <i>*ptr</i><b>, size_t</b>
<i>size</i><b>); <br>
void hbw_free(void</b> <i>*ptr</i><b>); <br>
size_t hbw_malloc_usable_size(void</b> <i>*ptr</i><b>); <br>
int hbw_posix_memalign(void</b> <i>**memptr</i><b>,
size_t</b> <i>alignment</i><b>, size_t</b> <i>size</i><b>);
<br>
int hbw_posix_memalign_psize(void</b> <i>**memptr</i><b>,
size_t</b> <i>alignment</i><b>, size_t</b> <i>size</i><b>,
hbw_pagesize_t</b> <i>pagesize</i><b>); <br>
hbw_policy_t hbw_get_policy(void); <br>
int hbw_set_policy(hbw_policy_t</b> <i>mode</i><b>); <br>
int hbw_verify_memory_region(void</b> <i>*addr</i><b>,
size_t</b> <i>size</i><b>, int</b> <i>flags</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>hbw_check_available</b>()
returns zero if high bandwidth memory is available or an
error code described in the <b>ERRORS</b> section if
not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_malloc</b>()
allocates <i>size</i> bytes of uninitialized high bandwidth
memory. The allocated space is suitably aligned (after
possible pointer coercion) for storage of any type of
object. If <i>size</i> is zero then <b>hbw_malloc</b>()
returns <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_calloc</b>()
allocates space for <i>nmemb</i> objects in high bandwidth
memory, each <i>size</i> bytes in length. The result is
identical to calling <b>hbw_malloc</b>() with an argument of
<i>nmemb</i> * <i>size</i>, with the exception that the
allocated memory is explicitly initialized to zero bytes. If
<i>nmemb</i> or <i>size</i> is 0, then <b>hbw_calloc</b>()
returns <i>NULL</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_realloc</b>()
changes the size of the previously allocated high bandwidth
memory referenced by <i>ptr</i> to <i>size</i> bytes. The
contents of the memory remain unchanged up to the lesser of
the new and old sizes. If the new size is larger, the
contents of the newly allocated portion of the memory are
undefined. Upon success, the memory referenced by <i>ptr</i>
is freed and a pointer to the newly allocated high bandwidth
memory is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
hbw_realloc</b>() may move the memory allocation, resulting
in a different return value than <i>ptr</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>ptr</i>
is <i>NULL</i>, the <b>hbw_realloc</b>() function behaves
identically to <b>hbw_malloc</b>() for the specified size.
If <i>size</i> is equal to zero, and <i>ptr</i> is not
<i>NULL</i>, then the call is equivalent to
<i>hbw_free(ptr)</i> and <i>NULL</i> is returned. The
address <i>ptr</i>, if not <i>NULL</i>, was returned by a
previous call to <b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
<b>hbw_realloc</b>() or <b>hbw_posix_memalign</b>().
Otherwise, or if <i>hbw_free(ptr)</i> was called before,
undefined behavior occurs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
hbw_realloc</b>() cannot be used with a pointer returned by
<b>hbw_posix_memalign_psize</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_free</b>()
causes the allocated memory referenced by <i>ptr</i> to be
made available for future allocations. If <i>ptr</i> is
<i>NULL</i>, no action occurs. The address <i>ptr</i>, if
not <i>NULL</i>, must have been returned by a previous call
to <b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
<b>hbw_realloc</b>(), <b>hbw_posix_memalign</b>() or
<b>hbw_posix_memalign_psize</b>(). Otherwise, if
<i>hbw_free(ptr)</i> was called before, undefined behavior
occurs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_malloc_usable_size</b>()
returns the number of usable bytes in the block pointed to
by <i>ptr</i>, a pointer to a block of memory allocated by
<b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
<b>hbw_realloc</b>(), <b>hbw_posix_memalign</b>(), or
<b>hbw_posix_memalign_psize</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_posix_memalign</b>()
allocates <i>size</i> bytes of high bandwidth memory such
that the allocation&rsquo;s base address is an even multiple
of <i>alignment</i>, and returns the allocation in the value
pointed to by <i>memptr</i>. The requested <i>alignment</i>
must be a power of 2 at least as large as
<i>sizeof(void*)</i>. If <i>size</i> is 0, then
<b>hbw_posix_memalign</b>() returns 0, with a <i>NULL</i>
returned in <i>memptr</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_posix_memalign_psize</b>()
allocates <i>size</i> bytes of high bandwidth memory such
that the allocation&rsquo;s base address is an even multiple
of <i>alignment</i>, and returns the allocation in the value
pointed to by <i>memptr</i>. The requested <i>alignment</i>
must be a power of 2 at least as large as
<i>sizeof(void*)</i>. The memory will be allocated using
pages determined by the <i>pagesize</i> variable which may
be one of the following enumerated values: <b><br>
HBW_PAGESIZE_4KB</b></p>

<p style="margin-left:22%;">The four kilobyte page size
option. Note that with transparent huge pages enabled these
allocations may be promoted by the operating system to two
megabyte pages.</p>

<p style="margin-left:11%;"><b>HBW_PAGESIZE_2MB</b></p>

<p style="margin-left:22%;">The two megabyte page size
option. <b>Note:</b> This page size requires huge pages
configuration described in <b>SYSTEM CONFIGURATION</b>
section.</p>

<p style="margin-left:11%;"><b>HBW_PAGESIZE_1GB
(DEPRECATED)</b></p>

<p style="margin-left:22%;">This option allows the user to
specify arbitrary sizes backed by 1GB chunks of huge pages.
Huge pages are allocated even if the size is not a modulo of
1GB. <b>Note:</b> This page size requires huge pages
configuration described in <b>SYSTEM CONFIGURATION</b>
section.</p>

<p style="margin-left:11%;"><b>HBW_PAGESIZE_1GB_STRICT
(DEPRECATED)</b></p>

<p style="margin-left:22%;">The total size of the
allocation must be a multiple of 1GB with this option,
otherwise the allocation will fail. <b>Note:</b> This page
size requires huge pages configuration described in
<b>SYSTEM CONFIGURATION</b> section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
HBW_PAGESIZE_2MB</b>, <b>HBW_PAGESIZE_1GB</b> and
<b>HBW_PAGESIZE_1GB_STRICT</b> options are not supported
with <b>HBW_POLICY_INTERLEAVE</b> policy.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_get_policy</b>()
returns the current fallback policy when insufficient high
bandwidth memory is available.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_set_policy</b>()
sets the current fallback policy. The policy can be modified
only once in the lifetime of an application and before
calling <b>hbw_malloc</b>(), <b>hbw_calloc</b>(),
<b>hbw_realloc</b>(), <b>hbw_posix_memalign</b>(), or
<b>hbw_posix_memalign_psize</b>() function. <b><br>
Note:</b> If the policy is not set, than
<b>HBW_POLICY_PREFERRED</b> will be used by default. <b><br>
HBW_POLICY_BIND</b></p>

<p style="margin-left:22%;">If insufficient high bandwidth
memory from the nearest NUMA node is available to satisfy a
request, the allocated pointer is set to <i>NULL</i> and
<i>errno</i> is set to <b>ENOMEM</b>. If insufficient high
bandwidth memory pages are available at fault time the Out
Of Memory (OOM) Killer is triggered. Note that pages are
faulted exclusively from the high bandwidth NUMA node
nearest at time of allocation, not at time of fault.</p>

<p style="margin-left:11%;"><b>HBW_POLICY_BIND_ALL</b></p>

<p style="margin-left:22%;">If insufficient high bandwidth
memory is available to satisfy a request, the allocated
pointer is set to <i>NULL</i> and <i>errno</i> is set to
<b>ENOMEM</b>. If insufficient high bandwidth memory pages
are available at fault time the Out Of Memory (OOM) Killer
is triggered. Note that pages are faulted from the high
bandwidth NUMA nodes. Nearest NUMA node is selected at time
of page fault.</p>


<p style="margin-left:11%;"><b>HBW_POLICY_PREFERRED</b></p>

<p style="margin-left:22%;">If insufficient memory is
available from the high bandwidth NUMA node closest at
allocation time, fall back to standard memory (default) with
the smallest NUMA distance.</p>


<p style="margin-left:11%;"><b>HBW_POLICY_INTERLEAVE</b></p>

<p style="margin-left:22%;">Interleave faulted pages from
across all high bandwidth NUMA nodes using standard size
pages (the Transparent Huge Page feature is disabled).</p>


<p style="margin-left:11%; margin-top: 1em"><b>hbw_verify_memory_region</b>()
verifies if memory region fully falls into high bandwidth
memory. Returns 0 if memory address range from <i>addr</i>
to <i>addr</i> + <i>size</i> is allocated in high bandwidth
memory, -1 if any fragment of memory was not backed by high
bandwidth memory (e.g. when memory is not initialized) or
one of error codes described in <b>ERRORS</b> section.</p>

<p style="margin-left:11%; margin-top: 1em">Using this
function in production code may result in serious
performance penalty.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>Flags</i> argument may include optional flags that modify
function behavior: <b><br>
HBW_TOUCH_PAGES</b></p>

<p style="margin-left:22%;">Before checking pages, function
will touch first byte of all pages in address range starting
from <i>addr</i> to <i>addr</i> + <i>size</i> by read and
write (so the content will be overwritten by the same data
as it was read). Using this option may trigger Out Of Memory
Killer.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>hbw_get_policy</b>()
returns <b>HBW_POLICY_BIND, HBW_POLICY_BIND_ALL,
HBW_POLICY_PREFERRED</b> or <b>HBW_POLICY_INTERLEAVE</b>
which represents the current high bandwidth policy.
<b>hbw_free</b>() do not have return value.
<b>hbw_malloc</b>() <b>hbw_calloc</b>() and
<b>hbw_realloc</b>() return the pointer to the allocated
memory, or <i>NULL</i> if the request fails.
<b>hbw_posix_memalign</b>(),
<b>hbw_posix_memalign_psize</b>() and
<b>hbw_set_policy</b>() return zero on success and return an
error code as described in the <b>ERRORS</b> section below
on failure.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Error codes
described here are the POSIX standard error codes as <br>
defined in</p>

<p style="margin-left:22%;"><i>&lt;errno.h&gt;</i></p>


<p style="margin-left:11%;"><b>hbw_check_available</b>()</p>

<p style="margin-left:22%;">returns <b>ENODEV</b> if
high-bandwidth memory is unavailable.</p>

<p style="margin-left:11%;"><b>hbw_posix_memalign</b>() and
<b>hbw_posix_memalign_psize</b>()</p>

<p style="margin-left:22%;">If the <i>alignment</i>
parameter is not a power of two, or was not a multiple of
<i>sizeof(void*)</i>, then <b>EINVAL</b> is returned. If the
policy and <i>pagesize</i> combination is unsupported then
<b>EINVAL</b> is returned. If there was insufficient memory
to satisfy the request then <b>ENOMEM</b> is returned.</p>

<p style="margin-left:11%;"><b>hbw_set_policy</b>()</p>

<p style="margin-left:22%;">returns <b>EPERM</b> if
<b>hbw_set_policy</b>() was called more than once, or
<b>EINVAL</b> if <i>mode</i> argument was neither
<b>HBW_POLICY_PREFERRED</b>, <b>HBW_POLICY_BIND</b>,
<b>HBW_POLICY_BIND_ALL</b> nor
<b>HBW_POLICY_INTERLEAVE</b>.</p>


<p style="margin-left:11%;"><b>hbw_verify_memory_region</b>()</p>

<p style="margin-left:22%;">returns <b>EINVAL</b> if
<i>addr</i> is <i>NULL</i>, <i>size</i> equals 0 or
<i>flags</i> contained unsupported bit set. If memory
pointed by <i>addr</i> could not be verified then
<b>EFAULT</b> is returned.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>&lt;hbwmalloc.h&gt;</i> file defines the external
functions and enumerations for the hbwmalloc library. These
interfaces define a heap manager that targets high bandwidth
memory numa nodes.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/usr/bin/memkind-hbw-nodes</i></p>

<p style="margin-left:22%;">Prints a comma-separated list
of high bandwidth nodes.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MEMKIND_HBW_NODES</b></p>

<p style="margin-left:22%;">This environment variable is a
comma-separated list of NUMA nodes that are treated as high
bandwidth. Uses the <i>libnuma</i> routine
<b>numa_parse_nodestring</b>() for parsing, so the syntax
described in the <b>numa</b>(3) man page for this routine
applies for example: 1-3,5 is a valid setting.</p>


<p style="margin-left:11%;"><b>MEMKIND_ARENA_NUM_PER_KIND</b></p>

<p style="margin-left:22%;">This environment variable
allows leveraging internal mechanism of the library for
setting number of arenas per kind. Value should be a
positive integer (not greater than <b>INT_MAX</b> defined in
<i>&lt;limits.h&gt;</i>). The user should set the value
based on the characteristics of application that is using
the library. Higher value can provide better performance in
extremely multithreaded applications at the cost of memory
overhead. See section <b>IMPLEMENTATION NOTES</b> of
<b>jemalloc</b>(3) for more details about arenas.</p>


<p style="margin-left:11%;"><b>MEMKIND_HEAP_MANAGER</b></p>

<p style="margin-left:22%;">Controls heap management
behavior in memkind library by switching to one of the
available heap managers. <br>
Values: <br>
JEMALLOC - sets the jemalloc heap manager <br>
TBB - sets the Intel Threading Building Blocks heap manager.
This option requires installed <br>
Intel Threading Building Blocks library.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b> If
the <b>MEMKIND_HEAP_MANAGER</b> is not set then the jemalloc
heap manager will be used by default.</p>

<h2>SYSTEM CONFIGURATION
<a name="SYSTEM CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining 2MB (HUGETLB) memory need allocated huge pages in
the kernel&rsquo;s huge page pool. <b><br>
HUGETLB (huge pages)</b></p>

<p style="margin-left:22%;">Current number of
&quot;persistent&quot; huge pages can be read from
<i>/proc/sys/vm/nr_hugepages</i> file. Proposed way of
setting hugepages is: <b>sudo sysctl
vm.nr_hugepages=&lt;number_of_hugepages&gt;</b>. More
information can be found here:
<a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</a></p>

<h2>KNOWN ISSUES
<a name="KNOWN ISSUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>HUGETLB
(huge pages)</b></p>

<p style="margin-left:22%;">There might be some overhead in
huge pages consumption caused by heap management. If your
allocation fails because of OOM, please try to allocate
extra huge pages (e.g. 8 huge pages).</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2014 - 2020 Intel Corporation. All rights reserved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>malloc</b>(3),
<b>numa</b>(3), <b>numactl</b>(8), <b>mbind</b>(2),
<b>mmap</b>(2), <b>move_pages</b>(2), <b>jemalloc</b>(3),
<b>memkind</b>(3)</p>
<hr>
</body>
</html>
